


			    Vim reference manual
				      
			     By Bram Moolenaar
				      
				version 3.0
				      

There is a contents listing at the end of this document.

The commands and options for multiple windows and buffers are explained in a
separate document: windows.doc



	1. Introduction

Vim stands for Vi IMproved. It used to be Vi IMitation, but that does not
really cover it anymore. Vim is a text editor which includes almost all the
commands from the Unix program "Vi" (and a lot new ones). It is very useful
for editing programs and other ASCII text. All commands are given with the
keyboard. There is no mouse support and there are no menus. This gives the
advantage that you can keep your fingers on the keyboard and your eyes on
the screen.

Throughout this manual the differences between Vi and Vim are mentioned in 
curly braces. Read the file "difference.doc" for a summary of the 
differences.

This manual refers to Vim on the Commodore Amiga computer. On other 
computers and on terminals there may be small differences. For MSDOS this 
is documented in msdos.doc. For UNIX this is in unix.doc.

This manual is a reference for all the Vim commands and options. A basic
knowledge of "Vi" is assumed. A summary of this manual can be found in the 
file vim.hlp. It can be accessed from within Vim with the <HELP> key (in 
MSDOS <F1>) and with the command ":help". The 'helpfile' option can be 
set to the name of the help file, so you can put it in any place you like.


	2. Notation

[]		Characters in square brackets are optional.

[count]		An optional number that may precede the command to multiply
		or iterate the command. If no number is given a count of one
		is used, unless otherwise noted. Note that in this manual
		the [count] is not mentioned in the description of the
		command, but only in the explanation. This was done to make
		the commands easier to lookup. If the "sc" option is on, the
		(partially) entered count is shown at the bottom of the
		window. You can use <DEL> to erase the last digit.

["x]		An optional register designation where text can be stored.
		The x is a single character between <a> and <z> or <A> and
		<Z> or <">, and in some cases (with the put command) between
		<0> and <9>, <%>, <:> or <.>. The uppercase and lower case
		letter designate the same register, but the lower case letter
		is used to overwrite the previous register contents, while the
		uppercase letter is used to append to the previous register
		contents. Without the ""x" or with """" the stored text is
		put into the unnamed register. See also "Copying and moving
		text".

{}		Curly braces denote parts of the command which must appear, 
		but can take a number of different values. The differences 
		between Vim and Vi are also given in curly braces (this will 
		be clear from the context).

{motion}	A command that moves the cursor. They are listed in chapter 
		6. This is used after an "operator" command to move over the 
		text that is to be operated upon. If the motion includes a 
		count and the operator also had a count, the two counts are 
		multiplied. For example: "2d3w" deletes six words.

{visual}	A piece of text that is started with the "v", "V" or CTRL-V
		command and ended by the cursor position. This is used
		before an "operator" to highlight the text that is to be
		operated upon. See the chapter on Visual mode.

<character>	A special character from the table below or a single ASCII
		character.

<char1-char2>	A single character from the range <char1> to <char2>. For
		example: <a-z> is a lower case letter. Multiple ranges may be
		concatenated. For example: <a-zA-Z0-9> is any alphanumeric
		character.

CTRL-<char>	<char> typed as a control character, that is, typing <char>
		while holding the CTRL key down. The case of <char> does not
		matter, thus CTRL-A and CTRL-a are equivalent.

'option'	An option, or parameter, that can be set to a value is
		enclosed in single quotes. See chapter 19.

"command"	In examples the commands you can type are enclosed in double
		quotes.


notation	meaning		     equivalent decimal value
-----------------------------------------------------------------------
<NUL>		zero			CTRL_@  000 (internally 010)
<BELL>  	bell			CTRL-G	007
<BS>    	backspace		CTRL-H	008
<TAB>   	tab			CTRL-I	009
<LF>    	linefeed		CTRL-J	010
<FF>    	formfeed		CTRL-L	012
<CR>    	carriage return		CTRL-M	013
<ESC>   	escape			CTRL-[	027
<SPACE>    	space				032
<DEL>   	delete				127
<C_UP>		cursor-up			128 (msdos: 176)
<C_DOWN>	cursor-down			129 (msdos: 177)
<C_LEFT>	cursor-left			130 (msdos: 178)
<C_RIGHT>	cursor-right			131 (msdos: 179)
<SC_UP>		shift-cursor-up			132 (msdos: 180)
<SC_DOWN>	shift-cursor-down		133 (msdos: 181)
<SC_LEFT>	shift-cursor-left		134 (msdos: 182)
<SC_RIGHT>	shift-cursor-right		135 (msdos: 183)
<F1> - <F10>	function keys 1 to 10		136 - 145 (msdos: 184 - 193)
<SF1> - <SF10>	shift-function keys 1 to 10	146 - 155 (msdos: 194 - 203)
HELP>		help key			156 (msdos: 204)
<UNDO>		undo key			157 (msdos: 205)
-----------------------------------------------------------------------
Note: The shifted cursor keys, the help key and the undo key are only
available on a few terminals. On some terminals the function keys 11 to 20
are used instead of the shifted function keys. On the Amiga shifted function
key 10 produces a code (CSI) that is also used by key sequences. It will be
recognized only after typing another key.


	3. Starting Vim

3.1 Command line

Most often Vim is started to edit a single file with the command

	vim file

More generally Vim is started with:

	vim [options] [filelist]

If the filelist is missing, the editor will start with an empty buffer.
Otherwise exactly one out of the following three may be used to choose one
or more files to be edited.

file ..		A list of file names. The first one will be the current file 
		and read into the buffer. The cursor will be positioned on 
		the first line of the buffer.

-t {tag}	A tag. "tag" is looked up in the tags file, the associated 
		file becomes the current file and the associated command is 
		executed. Mostly this is used for C programs. In that case 
		"tag" should be a function name. The effect is that the file 
		containing that function becomes the current file and the 
		cursor is positioned on the start of the function (see the 
		section "tag searches").

-e [errorfile]	QuickFix mode. The file with the name [errorfile] is read
		and the first error is displayed. If [errorfile] is not
		given, the 'errorfile' option is used for the file name
		(default "AztecC.Err" for the Amiga, "errors" for other
		systems). See section 5.5: "using the QuickFix mode".

The options, if present, must precede the filelist. The options may be given 
in any order.

+[num]		The cursor will be positioned on line "num" for the first
		file being edited. If "num" is missing, the cursor will be
		positioned on the last line.

+/{pat}		The cursor will be positioned on the first line containing
		"pat" in the first file being edited (see the section
		"pattern searches" for the available search patterns).

+{command}
-c {command}	"command" will be executed after the first file has been
		read. "command" is interpreted as an Ex command. If the
		"command" contains spaces it must be enclosed in double
		quotes (this depends on the shell that is used). Example:
		vim "+set si" main.c

-r		Recovery mode. The swap file is read to recover a 
		crashed editing session. See the chapter "Recovery after a
		crash".

-v		View mode. The 'readonly' option will be set and no 
		swap file will be written (see -n below). You can 
		still edit the buffer, but will be prevented from 
		accidentally overwriting a file. If you forgot that you are 
		in View mode and did make some changes, you can overwrite 
		a file by adding an exclamation mark to the Ex command, as in 
		":w!". The 'readonly' option can be reset with ":set noro" 
		(see the options chapter). Calling the executable "view" 
		has the same effect as the -v option. If your system does 
		not support links and you do not want to have the executable 
		twice you could make an alias: "alias view vim -v".

-b		Binary mode. The 'textauto', 'textmode' and 'expandtab'
		options will be reset. The 'textwidth' option is set to 0.
		'modelines' is set to 0. The 'binary' option is set. This is
		done after reading the .vimrc/.exrc files but before reading
		a file. See also 5.6: "Editing binary files".

-n		No swap file will be used. Recovery after a crash will be
		impossible. Handy if you want to view or edit a file on a
		very slow medium (e.g. floppy). Can also be done with ":set
		uc=0". You can switch it on again by setting the 'uc' option
		to some value, e.g. ":set uc=100". Any files already being
		edited will not be affected by this.

-o[N]		Open N windows. If [N] is not given, one window is opened
		for every file given as argument. If there is not enough
		room, only the first few files get a window. If there are
		more windows than arguments, the last few windows will be
		editing an empty file.

-T {terminal}	Set the terminal type to "terminal". This influences the 
		codes that Vim will send to your terminal. This is normally 
		not needed, because Vim will be able to find out what type 
		of terminal you are using (See chapter 20).

-d {device}	Amiga only: The "device" is opened to be used for editing.
		Normally you would use this to set the window position and
		size: "-d con:x/y/width/height", e.g.
		"-d con:30/10/600/150". But you can also use it to start
		editing on another device, e.g. AUX:.

-x		Amiga only: Do not restart Vim to open a new window. This
		option should be used when Vim is started by a program that
		will wait for the edit session to finish (e.g. mail or
		readnews). See section 3.3.

-s {scriptin}	The script file "scriptin" is read. The characters in the 
		file are interpreted as if you had typed them. The same can 
		be done with the command ":source! {scriptin}". If the end 
		of the file is reached before the editor exits, further 
		characters are read from the keyboard. See also the section 
		"complex repeats".

-w {scriptout}	All the characters that you type are recorded in the file
		"scriptout", until you exit Vim. This is useful if you want 
		to create a script file to be used with "vim -s" or 
		":source!". See also the section "complex repeats".

Example for using a script file to change a name in several files:
	Create a file "subs.vi" containing substitute commands and a :wq
	command:

		:%s/Jones/Smith/g
		:%s/Allen/Peter/g
		:wq

	Execute Vim on all files you want to change:

		foreach i ( *.let ) vim -s subs.vi $i

If the executable is called "view" Vim will start in Readonly mode. This is 
useful if you can make a hard or symbolic link from "view" to "vim".
Starting in Readonly mode can also be done with "vim -v". 


3.2 Workbench (Amiga only)

Vim can be started from the workbench by clicking on its icon twice. It will
then start with an empty buffer.

Vim can be started to edit one or more files by using a "Project" icon. The
"Default Tool" of the icon must be the full pathname of the Vim executable. 
The name of the ".info" file must be the same as the name of the text file. 
By clicking on this icon twice, Vim will be started with the filename as 
current filename, which will be read into the buffer (if it exists). You can 
edit multiple files by pressing the shift key while clicking on icons, and 
clicking twice on the last one. The "Default Tool" for all these icons must 
be the same.

It is not possible to give arguments to Vim, other than filenames, from the
workbench.


3.3 Vim window (Amiga only)

Vim will run in the CLI window where it was started. If Vim was started with 
the "run" or "runback" command, or if Vim was started from the workbench, it 
will open a window of its own.

Technical detail:
	To open the new window a little trick is used. As soon as Vim 
	recognizes that it does not run in a normal CLI window, it will 
	create a script file in t:. This script file contains the same 
	command as how Vim was started, and an "endcli" command. This script 
	file is then executed with a "newcli" command (the "c:run" and 
	"c:newcli" commands are required for this to work). The script file 
	will hang around until reboot, or until you delete it. This method 
	is required to get the ":sh" and ":!" commands to work correctly. 
	But when Vim was started with the -e option (Quickfix mode) or with 
	the -x option, this method is not used. The reason for this is that 
	when a compiler starts Vim with the -e option it will wait for a 
	return code. With the script trick the compiler cannot get the 
	return code. The -x option can be used when Vim is started by a mail 
	program which also waits for the edit session to finish. As a 
	consequence the ":sh" and ":!" commands are not available when the 
	-e or -x option is used.

Vim will automatically recognize the window size and react to window 
resizing. Under Amiga DOS 1.3 it is advised to use the fastfonts program 
"FF" to speed up display redrawing.


3.4 Initialization

When Vim starts running it does initializations in the following order. If
an environment variable is used, it is executed as a single Ex command line.
Multiple commands must be separated with <|> or <LF>. If a file is used,
each line is executed as an Ex command line.

1.  Four places are searched for initializations. The first that exists is 
    used, the others are ignored.
     1. The environment variable VIMINIT
     2. The file "s:.vimrc" (for Unix: "$HOME/.vimrc")
     3. The environment variable EXINIT
     4. The file "s:.exrc" (for Unix: "$HOME/.exrc")

2.  If the 'exrc' option is set (default is 'noexrc'), the current directory
    is searched for two files. The first that exists is used, the other is
    ignored.
     1. The file ".vimrc"
     2. The file ".exrc"

3.  The environment variable SHELL, if it exists, is used to set the 
    'shell' option. With MSDOS the COMPSPEC variable is used if SHELL does
    not exist. The 'shellpipe' option is set according to the name of the
    shell.

4.  The environment variable TERM, if it exists, is used to set the 'term'
    option.

The first can be used to set your default settings and mappings for all edit 
sessions. The second one for sessions in a certain directory (note that the
'exrc' option is default off). See the section "Saving settings" for how to
create a file with commands to recreate the current settings.

If the VIMINIT environment variable or ".vimrc" exist the EXINIT and ".exrc" 
are skipped. This can be used to initialize Vim without interfering with 
another version of Vi.

On the Amiga two types of environment variables exist. The ones set with the
DOS 1.3 (or later) setenv command are recognized. See the AmigaDos 1.3 
manual. The environment variables set with the old Manx Set command (before 
version 5.0) are not recognized.

On MS-DOS systems Vim assumes that all the "_vimrc" and "_exrc" files have
<CR><LF> pairs as line separators. This will give problems if you have a
file with only <LF>s and have a line like ":map xx yy^M". The trailing ^M
will be ignored.

While reading the ".vimrc" or the ".exrc" file in the current directory some
commands can be disabled for security reasons by setting the 'secure'
option. Otherwise it would be possible to create a .exrc that contains nasty
commands, which another user may automatically execute when he starts Vim it
that directory. The disabled commands are the ones that start a shell and
the ones that write to a file. The ":map" commands are echoed, so you can
see which keys are being mapped.

You can reset the 'secure' option in the EXINIT or VIMINIT environment
variable or in the global ".exrc" or ".vimrc" file. This is not possible in
".vimrc" or ".exrc" in the current directory, for obvious reasons.

On unix systems this only happens if you are not the owner of the ".vimrc" 
or ".exrc" file. Warning: If you unpack an archive that contains a .exrc 
file, it will be owned by you. You won't have the security protection. Check 
the .exrc file before you start Vim in that directory, or reset the 'exrc' 
option. 


3.5 Suspending

CTRL-Z				Suspend the editor. Same as ":stop".

:sus[pend][!]		or
:st[op][!]			Suspend the editor. If the <!> is not given,
				the buffer was changed, autowrite is set and 
				a filename is known, the buffer will be 
				written.

On many UNIX systems it is possible to suspend Vim with CTRL-Z. This is only 
possible in Command mode (see next chapter). Vim will continue if you make it 
the foreground job again. On other systems CTRL-Z will start a new shell. 
This is the same as the ":sh" command. Vim will continue if you exit from the 
shell.


	4. Modes

4.1 Introduction

Vim has four basic modes:

Command mode		In Command mode you can enter all the editor
			commands. If you start the editor you are in this 
			mode (unless you have set the 'insertmode' option, 
			see below).

Insert mode		In Insert mode the text you type is inserted into the
			buffer. If the 'showmode' option is set (which is
			default), the string "-- INSERT --" is shown at the
			bottom of the window.

Replace mode		Replace mode is a special case of Insert mode. You
			can do the same things as in Insert mode, but for 
			each character you enter (except some special 
			characters) one character of the existing text is 
			deleted. If the 'showmode' option is set (which is 
			default), the string "-- REPLACE --" is shown at the 
			bottom of the window.

Command_line mode	In Command_line mode you can enter one line of text
			at the bottom of the window. This is for the Ex
			commands <:>, the pattern search commands <?></> and
			the filter command <!>.

More explanation on the insert, replace and Command_line mode is further on 
in this chapter.


4.2 Switching from mode to mode

If for any reason you do not know in which mode you are, you can always get
back to Command mode by typing <ESC> twice. You will know you are back in
Command mode when you see the screen flash or hear the bell after you type
<ESC>.

- go from Command mode to Insert mode by giving one of the commands
  "iIaAoOcCsS".
- go from Command mode to Replace mode with the "R" command (not the "r"
  command!).
- go from Command mode to Command_line mode with the one of the commands
  ":/?!".

- go from insert or Replace mode to Command mode with <ESC> (twice in some
  rare cases).
- go from Command_line mode to Command mode by:
   - hitting <CR> or <LF>, which causes the entered command to be executed
   - deleting the complete line (e.g. with CTRL-U) and giving a final <BS>
   - hitting CTRL-C or <ESC>, which quits the command line without executing
     the command.
  In the last case <ESC> may be the character defined with the 'wildchar'
  option, and start command line completion. You can ignore that and type
  <ESC> again. {vi: when hitting <ESC> the command line is executed. This is
  unexpected for most people, therefore it was changed in Vim. But when the
  <ESC> is part of a mapping the command line is executed. If you want the
  vi behaviour also when typing <ESC> use ":cmap ^V<ESC> ^V^M"}

If the 'insertmode' option is set, editing a file will start in Insert mode.


4.3 Insert and Replace mode

4.3.1 special keys

In insert and Replace mode the following characters have a special meaning,
other characters are inserted directly. To insert one of these special
characters into the buffer, precede it with CTRL-V. To insert a <NUL> 
character use "CTRL-V CTRL-@" or "CTRL-V 000". On some systems you have to
use "CTRL-V 003" to insert a CTRL-C.

char		action
-----------------------------------------------------------------------
CTRL-@		Insert previously inserted text and stop insert. {Vi: only
		when typed as first char, only up to 128 chars}
CTRL-A		Insert previously inserted text. {not in Vi}
CTRL-B		Toggle the 'revins' option (B for Backwards). {not in Vi}
CTRL-C		Quit insert mode, back to command mode. Do not check for
		abbreviations.
CTRL-D		Delete one shiftwidth of indent at the start of the current 
		line. See also 'shiftround' option. When preceded with <^>
		or <0> delete all indent in the current line. With <^> the
		indent is restored in the next line. This is useful when
		inserting a label. {Vi: CTRL-D works only when used after
		autoindent}
CTRL-E		Insert the character which is below the cursor. {not in Vi}
CTRL-H <BS>	Delete the character before the cursor (see below). {Vi: 
		does not delete autoindents}
CTRL-I <TAB>    Insert a tab. If the 'expandtab' option is on, the
		equivalent number of spaces is inserted (use CTRL-V <TAB> to
		avoid the expansion). See also the 'smarttab' option, section
		4.3.4.
CTRL-J <LF>	Begin new line.
CTRL-K {char1} {char2}
		Enter digraph (see 4.7). {not in Vi}
CTRL-M <CR>	Begin new line.
CTRL-N		Find next keyword (see 4.3.7). {not in Vi}
CTRL-O		Execute one Command mode command. See below. {not in Vi}
CTRL-P		Find previous keyword (see 4.3.7). {not in Vi}
CTRL-R <0-9a-z"%:>
		Insert the contents of a numbered or named register. The
		text is inserted as if you typed it, but mappings and
		abbreviations are not used. If you have options like
		'textwidht' or 'autoindent' set, this will influence what
		will be inserted. Use <"> for the unnamed register,
		containing the text of the last delete or yank. Use <%> for
		the current file name.  Use <:> for the last command line. See
		the chapter on copying and moving text about registers. {<%>,
		<"> and <:> not in Vi}
CTRL-T		Insert one shiftwidth of indent at the start of the current 
		line. See also 'shiftround' option. {Vi: only when in 
		autoindent}
CTRL-U		Delete all entered characters in the current line (see 
		below).
CTRL-V		Insert next non-digit literally. Up to three digits form the 
		decimal value of a single byte. The non-digit and the three
		digits are not considered for mapping. {Vi: no decimal byte
		entry}
CTRL-W		Delete the word before the cursor (see below). See the 
		section "word motions" for the definition of a word.
CTRL-Y		Insert the character which is above the cursor. {not in Vi}
CTRL-[ or <ESC>	End insert or Replace mode, back to Command mode.
<DEL>		Same as CTRL-H <BS>
-----------------------------------------------------------------------

The effect of the <BS>, <DEL>, CTRL-W and CTRL-U depends on the 'backspace' 
option (unless 'revins' is set):

backspace	action
 option
   0	   delete stops in column 1 and start position of insert
   1	   delete stops at start position of insert
   2	   delete always, CTRL-W and CTRL-U stop once at start position of 
   	   insert

If the 'backspace' option is non-zero and the cursor is in column 1 when one 
of the three keys is used, the current line is joined with the previous 
line. This effectively deletes the newline in front of the cursor. {Vi: does 
not cross lines, does not delete past start position of insert}

With CTRL-V followed by one, two or three digits you can enter the decimal 
value of a byte, except 10. Normally CTRL-V is followed by three digits. The 
formed byte is inserted as soon as you type the third digit. If you type 
only one or two digits and then a non-digit, the decimal value of those one 
or two digits form the byte. After that the non-digit is dealt with in the 
normal way. If you enter a value of 10, it will end up in the file as a 0.
The 10 is a <LF>, which is used internally to represent the <NUL> character.
When writing the buffer to a file the <LF> character is translated into
<NUL>. The <LF> character is written at the end of each line. Thus if you
want to insert a <LF> character in a file you will have to make a line
break.


4.3.2 special special keys

The following keys are special. They stop the current insert, do something 
and then restart insertion. This means you can do something without getting 
out of Insert mode. This is very handy if you prefer to use the Insert mode 
all the time, just like editors that don't have a separate Command mode. You 
may also want to set the 'backspace' option to 2 and set the 'insertmode' 
option. You can use CTRL-O if you want to map a function key to a command.

The changes (inserted or deleted characters) before and after these keys can 
be undone separately. Only the last change can be redone and always behaves 
like an "i" command.

char		action
-----------------------------------------------------------------------
<C_UP>		cursor one line up
<C_DOWN>	cursor one line down
<C_LEFT>	cursor one character left
<C_RIGHT>	cursor one character right
<SC_UP>		move window one page up
<SC_DOWN>	move window one page down
<SC_LEFT>	cursor one word back (like "b" command)
<SC_RIGHT>	cursor one word forward (like "w" command)
CTRL-O		execute one command and return to Insert mode
-----------------------------------------------------------------------

The CTRL-O command has one side effect: If the cursor was beyond the end of 
the line it will be put on the last character in the line.
The shifted cursor keys are not available on all terminals.

When the 'whichwrap' option is set appropriately, the <C_LEFT> and <C_RIGHT>
keys on the first/last character in the line make the cursor wrap to the
previous/next line.


4.3.3 'textwidth' and 'wrapmargin' option

The 'textwidth' option can be used to automatically break a line before it 
gets too long. Set the 'textwidth' option to the desired maximum line 
length. If you then type more characters (not spaces or tabs), the 
last word will be put on a new line (unless it is the only word on the 
line). If you set 'textwidth' to 0, this feature is disabled.

The 'wrapmargin' option does almost the same. The difference is that
'textwidth' has a fixed width while 'wrapmargin' depends on the width of the
screen. When using 'wrapmargin' this is equal to using 'textwidth' with a
value equal to (columns - 'wrapmargin'), where columns is the width of the
screen.

When 'textwidth' and 'wrapmargin' are both set, 'textwidth' is used.

The line is only broken automatically when using insert mode, or when
appending to a line. When in replace mode and the line length is not
changed, the line will not be broken.

If you want to format a block of text you can use the "Q" operator. Type "Q" 
and a movement command to move the cursor to the end of the block. In many 
cases the command "Q}" will do what you want (format until the end of 
paragraph). Or you can use visual mode: hit "v", move to the end of the
block and hit "Q".


4.3.4 'expandtab' and 'smarttab' options

If the 'expandtab' option is set, spaces will be used to fill the amount of
whitespace of the tab. If you want to enter a real <TAB> type CTRL-V first.
The 'expandtab' option is default off. Note that in Replace mode a single
character is replaced by several spaces. The result of this is that the
number of characters in the line increases. Backspacing will delete one
space at a time. The original text will be put back in a place where you
would not expect it. {not in Vi}

When the 'smarttab' option is set a TAB in front of a line inserts
'shiftwidth' positions, 'tabstop' in other places. This means that often
spaces instead of a TAB character is inserted. When not set a TAB always
inserts 'tabstop' positions, 'shiftwidth' is only used for ">>" and the like.
{not in Vi}


4.3.5 typing backwards

If the 'revins' (reverse insert) option is set, inserting happens backwards.
This can be used to type Hebrew. When inserting characters the cursor is not
moved and the text moves rightwards. A <BS> deletes the character under the
cursor. CTRL-W and CTRL-U also work in the opposite direction. <BS>, CTRL-W
and CTRL-U do not stop at the start of insert or end of line, no matter how
the 'backspace' option is set.

In Replace mode the cursor is moved leftwards. <BS> will restore the
character right of the cursor.

In insert or Replace mode the 'revins' option can be toggled with CTRL-B.

If the 'showmode' option is set, "-- REVERSE INSERT --" or
"-- REVERSE REPLACE --" will be shown in the status line.


4.3.6 Replace mode

In Replace mode one character in the line is deleted for every character you 
type. If there is no character to delete (at the end of the line), the 
typed character is appended (as in Insert mode). Thus the number of 
characters in a line stays the same until you get to the end of the line.

Be careful with <TAB> characters. If you type a normal printing character in 
its place, the number of characters is still the same, but the number of 
columns will become smaller.

If you delete characters in Replace mode (with <BS>, <DEL>, CTRL-W or
CTRL-U), you really delete your changes. The characters that were replaced
are restored. If you had typed past the existing text, the characters you
added are deleted.
    All this only works in the current line. If you have started a new line
(replaced a character with a <CR>) Vim no longer remembers what happened in
the previous line. If you backspace over the newline (only possible if the
'backspace' option is non-zero), the two lines will be joined again, but
typing further backspaces will not restore the original text. Only the
cursor is moved.
    If the 'expandtab' option is set, a <TAB> will replace one character
with several spaces. When backspacing over these spaces, the original text
will appear in a position where you would not expect it.


4.3.7 Keyword completion

In insert and replace mode the keys CTRL-N and CTRL-P can be used to
complete the keyword that is in front of the cursor. This is useful if you
are writing a program that has complicated variable names, and you want to
copy a name from the text before of after the cursor.

If there is an identifier in front of the cursor (a name made out of
alphanumeric characters and <_>) it is used as the search pattern, with "\<"
prepended (meaning: start of a word). Otherwise "\<[a-zA-Z_]" is used as
search pattern (start of any identifier).

With CTRL-N (next) the search goes forward, with CTRL-P (previous) the
search goes backward. The first time the search starts where the cursor is.
The next times the search starts at the last found position. If you type any
other character than CTRL-P or CTRL-N the current text is accepted and the
search pattern is forgotten.

If the search found a match, it is inserted at the cursor position. Any
previous match is replaced. If no match was found, Vim will beep.

If there is not a valid identifier character before the cursor, any
identifier is matched.
	eg. to get:
	    printf("(%g, %g, %g)", vector[0], vector[1], vector[2]);
	just type:
	    printf("(%g, %g, %g)", vector[0], ^P[1], ^P[2]);

Multiple repeats of the same completion are skipped.

If there is only one completion found, then a second CTRL-P or CTRL-N will
give the message 'No other matches'.

If the only match in the file is an exact match, where no extra characters
would be typed, then the message 'Exact match only' is given (this is also
useful for checking that you typed the symbol correctly).

The mode (--INSERT--) is shown, unless there is another more important
message (eg Pattern not found).  This other message will stay until another
key is hit, and then the mode is shown again.

Only matches where something extra will be added are used.
	eg. to get:
	    printf("name = %s\n", name);
	just type:
	    printf("name = %s\n", n^P);
The 'n' in '\n' is skipped.


4.4 Command_line mode

Command_line mode is used to enter Ex commands <:>, search patterns </><?>
and filter commands <!>.


4.4.1 Command line editing

Normal characters are inserted in front of the cursor position. You can move
around in the command line with the left and right cursor keys. {Vi: can 
only alter the last character in the line}

The command lines that you enter are remembered in a history table. You can
recall them with the up and down cursor keys. Use the 'history' option to 
set the number of lines that are remembered (default 20).

There is an automatic completion of names on the command line, see 4.4.2.

CTRL-V		Insert next non-digit literally. Up to three digits form the 
		decimal value of a single byte. The non-digit and the three
		digits are not considered for mapping. This works the same
		way as in Insert mode (see above).
<C_LEFT>	cursor left
<C_RIGHT>	cursor right
<SC_LEFT>	cursor one word left
<SC_RIGHT>	cursor one word right
CTRL-B		cursor to begin of command line
CTRL-E		cursor to end of command line

<BS>		delete the character in front of the cursor
<DEL>		delete the character under the cursor (at end of line:
		character in front of the cursor)
CTRL-W		delete the word in front of the cursor
CTRL-U		remove all characters

		Note: if the command line becomes empty with one of the
		delete commands, command line mode is quit.

{char1} <BS> {char2}	or
CTRL-K {char1} {char2}
		enter digraph (see 4.7). {not in Vi}

<CR> or <LF>	start entered command
<ESC>		when typed: quit command line without executing
		in macros: start entered command
CTRL-C		quit command line without executing

<C_UP>		recall older command line from history
<C_DOWN>	recall more recent command line from history

<SC_UP>		recall older command line from history, which begin matches 
		the current command line (see below).
<SC_DOWN>	recall more recent command line from history, which begin 
		matches the current command line (see below).

CTRL-D		command line completion (see 4.4.2)
'wildchar' option
		command line completion (see 4.4.2)
CTRL-N		command line completion (see 4.4.2)
CTRL-P		command line completion (see 4.4.2)
CTRL-A		command line completion (see 4.4.2)
CTRL-L		command line completion (see 4.4.2)

The <SC_UP> and <SC_DOWN> keys take the current command line as search 
string. The beginning of the next/previous command lines are compared against 
this string. The fist line that matches is the new command line. When typing 
these two keys repeatedly, the same string is used again. For example this 
can be used to find the previous substitute command: Type ":s" and then 
<SC_UP>. The same could be done by typing <C_UP> a number of times until the 
desired command line is shown. (Note: the shifted arrow keys do not work on
all terminals) 


4.4.2 Command line completion

When editing the command line a few commands can be used to complete the
word before the cursor. This is available for:

- Command names, at the start of the command line. Works always.
- tags, only after the ":tag" command.
- file names, only after a command that accepts a file name or a setting for
  an option that can be set to a file name. This is called file name
  completion.
- options, only after the ":set" command.

These are the commands that can be used:

CTRL-D		List names that match the pattern in front of the cursor.
		When showing file names, directories are highlighted (see
		'highlight' option)
'wildchar' option
		A match is done on the pattern in front of the cursor. The
		match, or if there are several, the first match, is inserted
		in place of the pattern. (Note: does not work inside a
		macro, because TAB or ESC is mostly used as 'wildchar', and
		these have a special meaning in some macros)
		When typed again, and there were multiple matches, the next
		match is inserted. After the last match the first is used
		again (wrap around).
CTRL-N		After using 'wildchar' which got multiple matches: go to next
		match. Otherwise: Recall more recent command line from history.
CTRL-P		After using 'wildchar' which got multiple matches: go to
		previous match. Otherwise: Recall older command line from
		history.
CTRL-A		All names that match the pattern in front of the cursor are
		inserted.
CTRL-L		A match is done on the pattern in front of the cursor. If
		there is one match, it is inserted in place of the pattern.
		If there are multiple matches the longest common part is
		inserted in place of the pattern.

The 'wildchar' option defaults to <TAB> (CTRL-E when compiled with 
COMPATIBLE; in a previous version <ESC> was used). In the pattern standard
wildcards <*> and <?> are accepted. <*> matches any string, <?> matches
exactly one character.

For filename completion you can use the 'suffixes' option to set a priority 
between files with almost the same name. If there are multiple matches, 
those files with an extension that is in the 'suffixes' option are ignored.
The default is ".bak.o.h.info.swp", which means that files with the
extensions ".bak", ".o", ".h", ".info" and ".swp" are sometimes ignored. It
is impossible to ignore suffixes with two dots. Examples:

pattern:	files:				match:
test*		test.c test.h test.o		test.c
test*		test.h test.o			test.h and test.o
test*		test.i test.h test.c		test.i and test.c

If there is more than one matching file (after ignoring the ones matching
the 'suffixes' option) the first file name is inserted. You can see that
there is only one match when you type 'wildchar' twice and the completed
match stays the same. You can get to the other matches by entering
'wildchar', CTRL-N or CTRL-P. All files are included, also the ones with
extensions matching the 'suffixes' option.


4.4.3 Ex command lines

The Ex commands have a few specialties:

<"> at the start of a line causes the whole line to be ignored. <"> 
after a command causes the rest of the line to be ignored. This can be used 
to add comments. Example:
	:set ai 	"set 'autoindent' option
It is not possible to add a comment to a shell command ":!cmd" or to the
":map" command and friends, because they see the <"> as part of their
argument.

<|> can be used to separate commands, so you can give multiple commands in 
one line. The commands ":global", "vglobal" and  ":!" see the <|> as their
argument, and can therefore not be followed by another command. If you want
<|> to be included in a command, precede it with <\>. Note that this is
confusing (inherited from vi). If you give a command with ":!" you don't
have to use a backslash, with ":r !" you have to. And with ":g" the <|> is
included in the command, with ":s" it is not. Examples:
	:!ls | wc		view the output of two commands
	:r !ls \| wc		insert the same output in the text
	:%g/foo/p|>		moves all matching lines one shiftwidth
	:%s/foo/bar/|>		moves one line one shiftwidth
You can also use <LF> to separate commands in the same way as with <|>. But
using <|> is the preferred method.

When the character <%> or <#> is used where a filename is expected, they are 
expanded to the current and alternate filename (see the chapter "editing 
files").

Embedded spaces in filenames are allowed if one filename is expected as
argument. Trailing spaces will be ignored, unless escaped with a backslash
or CTRL-V. Note that the ":next" command uses spaces to separate file names.
Escape the spaces to include them in a file name. Example:
	:next foo\ bar goes\ to school\ 
starts editing the three files "foo bar", "goes to" and "school ".

When you want to use the special characters <"> or  <|> in a command, or want
to use <%> or <#> in a filename, precede them with a backslash. The backslash
is not required in a range and in the ":substitute" command.


4.4.4 Ex command line ranges

Some Ex commands accept a line range in front of them. This is noted as
[range]. It consists of one or more line specifiers, separated with <,> or 
<;>. When separated with <;> the cursor position will be set to that line 
before interpreting the next line specifier. The default line specifier for 
most commands is the cursor position, but the commands ":write" and 
":global" have the whole file (1,$) as default. If more line specifiers are 
given than required for the command, the first one(s) will be ignored.

Line numbers may be specified with:
	{number}	an absolute line number
	.		the current line
	$		the last line in the file
	%		equal to 1,$ (the entire file)
	't		position of mark t (lower case)
	/{pattern}[/]	the next line where {pattern} matches
	?{pattern}[?]	the previous line where {pattern} matches

Each may be followed (several times) by <+> or <-> and an optional number. 
This number is added or subtracted from the preceding line number. If the 
number is omitted, 1 is used.

The "/" and "?" may be preceded with another address. The search starts from
there. The "/" and "?" after {pattern} are required to separate the pattern
from anything that follows.

The {number} must be between 0 and the number of lines in the file. A 0 is 
interpreted as a 1, except with the commands tag, pop and read.

Examples:
	.+3		three lines below the cursor
	/that/+1	the line below the next line containing "that"
	.,$		from current line until end of file
	0/that		the first line containing "that"

Some commands allow for a count after the command. This count is used as the
number of lines to be used, starting with the line given in the last line
specifier (the default is the cursor line). The commands that accept a count
are the ones that use a range but do not have a file name argument (because
a file name can also be a number).

Examples:
	:s/x/X/g 5	substitute <x> by <X> in the current line and four
			following lines
	:23d 4		delete lines 23, 24, 25 and 26

A range should have the lower line number first. If this is not the case, Vim
will ask you if it should swap the line numbers. This is not done within the
global command ":g".

When giving a count before entering ":", this is translated into:
		:.,.+(count - 1)
In words: The 'count' lines at and after the cursor. Example: To delete
three lines:
		3:d<CR>		is translated into: .,.+2d<CR>


4.5 The window contents

In command and Insert/Replace mode the screen window will show the current
contents of the buffer: What You See Is What You Get. {Vi: when changing 
text a <$> is placed on the last changed character; The window is not always 
updated on slow terminals} Lines longer than the window width will wrap,
unless the 'wrap' option is off (see below). The bottom lines in the window
may start with one of these two characters:

<@> 	The next line is too long to fit in the window.
<~>	Below the last line in the buffer.

If the bottom line is completely filled with <@>, the line that is at the 
top of the window is too long to fit in the window. If the cursor is on this 
line you can't see what you are doing, because this part of the line is not 
shown. However, the part of the line before the <@>s can be edited normally. 
{Vi: gives an "internal error" on lines that do not fit in the window}

If the 'wrap' option is off, long lines will not wrap. Only the part that
fits on the screen is shown. If the cursor is moved to a part of the line
that is not shown, the screen is scrolled horizontally. The advantage of
this method is that columns are shown as they are and lines that cannot fit
on the screen can be edited. The disadvantage is that you cannot see all the
characters of a line at once. The 'sidescroll' option can be set to the
minimal number of columns to scroll. {Vi: has no 'wrap' option}

All normal ASCII characters are displayed directly on the screen. The <TAB> 
is replaced by the number of spaces that it represents. Other non-printing 
characters are replaced by "^<char>", where <char> is the non-printing 
character with 64 added. Thus character 7 (bell) will be shown as "^G". 
Characters between 127 and 160 are replaced by "~<char>", where <char> is 
the character with 64 subtracted. These characters occupy more than one 
position on the screen. The cursor can only be positioned on the first one.

If you set the 'number' option, all lines will be preceded with their 
number.

If you set the 'list' option, <TAB> characters will not be shown as several
spaces, but as "^I". A <$> will be placed at the end of the line, so you can
find trailing blanks.

In Command_line mode only the command line itself is shown correctly. The
display of the buffer contents is updated as soon as you go back to Command
mode.

Some commands hand over the window to external commands (e.g. ":shell" and
"="). After these commands are finished the window may be clobbered with 
output from the external command, so it needs to be redrawn. This is also 
the case if something is displayed on the status line that is longer than 
the width of the window. If you are expected to have a look at the screen 
before it is redrawn, you get this message:

		Press RETURN or enter command to continue

After you type a key the screen will be redrawn and Vim continues. If you 
type <CR>, <SP> or <LF> nothing else happens. If you type any other key, it 
will be interpreted as (the start of) a new command. {Vi: only <:> commands 
are interpreted}

The last line of the window is used for status and other messages. The 
status messages will only be used if an option is on:

status message			option		default	unix default
current mode 			'showmode'	on	    on
command characters		'showcmd'	on	    off
cursor position			'ruler'		off	    off

The current mode is "-- INSERT --" or "-- REPLACE --". The command 
characters are those that you typed but were not used yet. {Vi: does not
show the characters you typed or the cursor position}

If you have a slow terminal you can switch off the status messages to speed 
up editing:
	:set nosc noru nosm

If there is an error, an error message will be shown for at least one second 
(in reverse video). {Vi: error messages may be overwritten with other 
messages before you have a chance to read them}

Some commands show how many lines were affected. Above which threshold this
happens can be controlled with the 'report' option (default 2).

On the Amiga Vim will run in a CLI window. The name Vim and the full name of
the current filename will be shown in the title bar. When the window is
resized, Vim will automatically redraw the window. You may make the window as
small as you like, but if it gets too small not a single line will fit in it.
Make it at least 40 characters wide to be able to read most messages on the
last line.

On most Unix systems window resize works ok.  {Vi: not ok}


4.6 Abbreviations

Abbreviations are used in insert mode, Replace mode and Command_line mode.
If you enter a word that is an abbreviation, it is replaced by the word it
stands for. This can be used to save typing for often used long words.

There are two types of abbreviations: The "full-id" type consists entirely
of id characters (letters, digits and <_> characters). This is the most
common abbreviation. The "non-id" type ends in an id character, but all the
other characters are not id characters. Examples of a "full-id" type are
"foo" and "c_1". Examples of a "non-id" type are "#i" and "$/7". Examples of
strings that will not be recognized as an abbreviation are "a.b", "a b" and
"_$ar".

The "full-id" abbreviation is recognized if:
- A character is typed that is not an id character. This can also be
  the <ESC> that ends insert mode or the <CR> that ends a command.
- The characters in front of the cursor match the abbreviation.
- In front of the match is a non-id character, or this is where the line or
  insertion starts. Exception: when the abbreviation is only one character,
  it is not recognized if there is a non-id character in front of it, other
  than a space or a TAB.

The "non-id" abbreviation is recognized if:
- A character is typed that is not an id character. This can also be
  the <ESC> that ends insert mode or the <CR> that ends a command.
- The characters in front of the cursor match the abbreviation.
- In front of the match is an id character, or a space or a TAB, or this is
  where the line or insertion starts.

Example: ":ab foo four old otters". Note that spaces in the <rhs> are
allowed and included in the replacement string. If you now insert the word
"foo" with a space before and after it, it will be replaced by "four old
otters". If you would type "foobar" or "barfoo" nothing happens.

To avoid the abbreviation in insert mode type part of the abbreviation, exit
insert mode with <ESC>, re-enter insert mode with "a" and type the rest. In
Command_line mode you can type CTRL-V twice somewhere in the abbreviation to
avoid it to be replaced. A CTRL-V in front of a normal character is mostly
ignored otherwise.

There are no default abbreviations.

Abbreviations are never recursive. You can use ":ab f f-o-o" without any
problem. But abbreviations can be mapped. {some versions of vi support
recursive abbreviations, for no apparent reason}

Abbreviations are disabled if the 'paste' option is set.

:ab[breviate]		list all abbreviations. The character in the first
			column indicates the mode where the abbreviation is
			used: 'i' for insert mode, 'c' for Command_line
			mode, '!' for both.

:ab[breviate] <lhs>	list the abbreviations that start with <lhs>

:ab[breviate] <lhs> <rhs>
			add abbreviation for <lhs> to <rhs>. If <lhs> already
			existed it is replaced with the new <rhs>. <rhs> may
			contain spaces.

:una[bbreviate] <lhs>	remove abbreviation for <lhs> from the list

:norea[bbrev] [lhs] [rhs]
			same as ":ab", but no remapping for this <rhs> {not
			in Vi}

:ca[bbrev] [lhs] [rhs]	same as ":ab", but for Command_line mode only. {not
			in Vi}

:cuna[bbrev] <lhs>	same as ":una", but for Command_line mode only. {not
			in Vi}

:cnorea[bbrev] [lhs] [rhs]
			same as ":ab", but for Command_line mode only and no
			remapping for this <rhs> {not in Vi}

:ia[bbrev] [lhs] [rhs]	same as ":ab", but for insert mode only. {not in Vi}

:iuna[bbrev] <lhs>	same as ":una", but for insert mode only. {not in
			Vi}

:inorea[bbrev] [lhs] [rhs]
			same as ":ab", but for insert mode only and no
			remapping for this <rhs> {not in Vi}


4.7 Digraphs

:dig[raphs]		show currently defined digraphs. {not in Vi}

:dig[raphs] {char1}{char2} {number} ...
			Add digraph {char1}{char2} to the list. {number} is 
			the decimal representation of the character.

Digraphs are used to enter characters that normally cannot be entered by 
an ordinary keyboard. These are mostly accented characters which have the 
eighth bit set. The digraphs are easier to remember than the decimal number
that can be entered with CTRL-V (see above).

Vim must have been compiled with the 'digraphs' option enabled. If not, the 
":digraph" command will display an error message.

There are two methods to enter digraphs:
	CTRL-K {char1} {char2}		or
	{char1} <BS> {char2}
The first is always available. The second only when the 'digraph' option is 
set.

Once you have entered the digraph the character is treated like a normal 
character, taking up only one character in the file and on the screen. 
Example:
	<|> <BS> <|>	will enter the double <|> character (166)
	<a> <BS> <^>	will enter an <a> with a hat (226)
	CTRL-K <-> <->	will enter a minus sign (173)

The default digraphs are listed in the file digraph.doc. They are meant for 
the Amiga character set, which is some international standard. With another 
character set they may be illogical.

For CTRL-K there is one general digraph: CTRL-K <SPACE> {char} will enter
{char} with the highest bit set. This can be used to enter meta-characters.

The <ESC> character cannot be part of a digraph. When hitting <ESC> entering
the digraph is aborted and insert mode too.

If you accidently typed an <a> that should be an <e>, you will type <a> <BS> 
<e>. But that is a digraph, so you will not get what you want. To avoid this, 
use <DEL> instead of <BS>. Or don't set the 'digraph' option and use CTRL-K
to enter digraphs.


	5. Editing files

5.1 Introduction

Editing a file with Vim means:

1. reading the file into the internal buffer
2. changing the buffer with editor commands
3. writing the buffer into a file

As long as you don't write the buffer, the original file remains unchanged. 
If you start editing a file (read a file into the buffer), the file name is 
remembered as the "current filename".

If there already was a current filename, then that one becomes the alternate
file name. All filenames are remembered in the file list. When you enter a
filename, for editing (e.g. with ":e filename") or writing (e.g. with (:w
filename"), the filename is added to the list. You can use this list to
remember which files you edited and to quickly switch from one file to
another with the CTRL-^ command (e.g. to copy text). First type the number
of the file and then hit CTRL-^. {Vi: only one alternate filename}

In Ex commands (the ones that start with a colon) <%> is replaced by the
current filename and <#> is replaced by the alternate filename. The older
alternate filenames are "#1", "#2", etc. "#0" is the same as "#". If a
"<" is appended to <%>, <#> or "#n" the extension of the file name is
removed (everything after and including the last '.' in the file name).

	%		current file name
	%<		current file name without extension
	#		alternate file name for current window
	#<		idem, without extension
	#31		alternate file number 31
	#31<		idem, without extension

CTRL-G		or
:f[ile]			Prints the current filename (as typed) and the
			cursor position. {vi does not include column number}

{count}CTRL-G		Prints the current filename with full path and the
			cursor position.

:f[ile] {name}		Sets the current filename to {name}.

:buffers
:files			List all the currently known file names. See
			'windows.doc'. {not in vi}

Vim will remember the full path name of a file name that you enter. In most
cases when the file name is displayed only the name you typed is shown, but
the full path name is being used if you used the ":cd" command.

If the environment variable 'HOME' is set, and the file name starts with
that string, it is often displayed with HOME replaced by "~". This was done
to keep file names short. When reading or writing files the full name is
still used, the "~" is only used when displaying file names.

When writing the buffer, the default is to use the current filename. Thus 
when you give the "ZZ" or ":wq" command, the original file will be 
overwritten. If you do not want this, the buffer can be written into another 
file by giving a filename argument to the ":write" command. For example:
	
	vim testfile
	[change the buffer with editor commands]
	:w newfile
	:q

This will create a file "newfile", that is a modified copy of "testfile". 
The file "testfile" will remain unchanged. Anyway, if the 'backup' option is 
set, Vim renames the original file before it will be overwritten. You can 
use this file if you discover that you need the original file. See also the
'patchmode' option. The name of the backup file is the same as the original
file with ".bak" appended. Any <.> is replaced by <_> on MSDOS machines, when
Vim has detected that an MSDOS-like filesystem is being used (e.g. messydos or
crossdos) and when the 'shortname' option is set.

Technical: On the Amiga you can use 30 characters for a file name. But on an 
	   MSDOS-compatible filesystem only 8 plus 3 characters are 
	   available. Vim tries to detect the type of filesystem when it is 
	   creating the .swp file. If an MSDOS-like filesystem is suspected, 
	   a flag is set that has the same effect as setting the 'shortname' 
	   option. This flag will be reset as soon as you start editing a 
	   new file. The flag will be used when making the filename for the 
	   ".swp" and ".bak" files for the current file. But when you are 
	   editing a file in a normal filesystem and write to an MSDOS-like 
	   filesystem the flag will not have been set. In that case the 
	   creation of the ".bak" file may fail and you will get an error 
	   message. Use the 'shortname' option in this case.

When you started editing without giving a file name, "No File" is displayed in
messages. If a ":write file" or ":read file" command is used, the file name
for the current file is set to the file name in that command. This is useful
when starting Vim without an argument and then doing ":read file" to start
editing a file. Or when entering text in an empty buffer and then writing it
to a file. Because the file name was set without really starting to edit that
file, you are protected from overwriting that file. This is done by setting
the "notedited" flag. You can see if this flag is set with the CTRL-G or
":file" command. It will include "[Not edited]" when the "notedited" flag is
set. When writing the buffer to the current file name (with ":w!"), the
"notedited" flag is reset.

Vim remembers whether you have changed the buffer. You are protected from
losing the changes you made. If you try to quit without writing, or want to
start editing another file, this will be refused. In order to overrule this
protection add a <!> to the command. The changes will then be lost. For
example: ":q" will not work if the buffer was changed, but ":q!" will. To see
whether the buffer was changed use the "CTRL-G" command. The message includes
the string "[Modified]" if the buffer has been changed.


5.2 Editing a file

:e[dit] [+cmd]		Edit the current file, unless changes have been made.

:e[dit]! [+cmd]		Edit the current file always. Discard any changes to
			the buffer.

:e[dit] [+cmd] {file}	Edit {file}, unless changes have been made.

:e[dit]! [+cmd] {file}	Edit {file} always. Discard any changes to the
			buffer.

:e[dit] #[count]        Edit the [count]th alternate filename (as shown by
                        :files). This command does the same as [count] CTRL-^.

:ex [+cmd] [file]	Same as :edit. {Vi: go from visual to Ex mode}

:vi[sual] [+cmd] [file]	Same as :edit. {Vi: go from Ex to Visual mode}

[count]CTRL-^		Edit [count]th alternate file (equivalent to ":e
			#[count]"). Without count this gets you to the
			previously edited file. This is a quick way to
			toggle between two (or more) files. If the
			'autowrite' option is set and the buffer was
			changed, write it.

]f
[f
gf			Edit the file whose name is under or after the
			cursor. Mnemonic: "goto file". This fails if the
			current file cannot be abandoned. {not in Vi}

:cd			On non-Unix systems: Print the current directory
			name. On Unix systems: Change the current directory
			to the home directory.

:cd {path}		Change the current directory to {path}. Does not
			change the meaning of an already entered file name,
			because its full path name is remembered.

:chd[ir] [path]		Same as :cd.

:pwd			Print the current directory name. {Vi: no pwd}

These commands are used to start editing a single file. This means that the
file is read into the buffer and the current filename is set. You may use the
":cd" command to get to another directory, so you will not have to type that 
directory name in front of the filenames. One warning: After using ":cd" the
full path name will be used for reading and writing files. On some networked
file systems this may cause problems. The result of using the full path name
is that the file names currently in use will remain referring to the same
file. Example: If you have a file a:test and a directory a:vim the commands
":e test" ":cd vim" ":w" will overwrite the file a:test and not write
a:vim/test. But if you do ":w test" the file a:vim/test will be written,
because you gave a new file name and did not refer to a file name before the
":cd".

You can use the ":e!" command if you messed up the buffer and want to start 
all over again. The ":e" command is only useful if you have changed the 
current filename.

The [+cmd] can be used to position the cursor in the newly opened file:
	+		Start at the last line.
	+{num}		Start at line {num}.
	+/{pat}		Start at first line containing {pat}. {pat} must not
			contain any spaces.
	+{command}	Execute {command} after opening the new file.
			{command} is an Ex command. It must not contain 
			spaces.

When reading a file when the 'textmode' option is off (default for
non-MSDOS) the <LF> character is interpreted as end-of-line. If 'textmode'
is on (default for MSDOS), <CR><LF> is also interpreted as end-of-line.

When writing a file when the 'textmode' option is off a <LF> character is
used to separate lines. When the 'textmode' option is on <CR><LF> is used.

You can read a file with 'textmode' set and write it with 'textmode' reset.
This will replace all <CR><LF> pairs by <LF>. If you read a file with
'textmode' reset and write with 'textmode' set, all <LF> characters will be
replaced by <CR><LF>.

If you start editing a new file and the 'textauto' option is set, Vim will
try to detect whether the lines in the file are separated by a single <LF>
(as used on Unix and Amiga) or by a <CR><LF> pair (MSDOS). It reads up to
the first <LF> and checks if there is a <CR> in front of it. If there is the
'textmode' option is set, otherwise it is reset. If the 'textmode' option is
set on non-MSDOS systems the message "[textmode]" is shown to remind you
that something unusual is happening. On MSDOS systems you get the message
"[notextmode]" if the 'textmode' option is not set.

Before editing binary, executable or Vim script files you should set the
'textmode' and 'textauto' options off. With 'textmode' on you risk that
single <LF> characters are unexpectedly replaced with <CR><LF>. A simple way
to do this is by starting Vim with the "-b" option.


5.3 The argument list

If you give more than one filename when starting Vim, this list is
remembered as the argument list. Do not confuse this with the file list,
which you can see with the ":files" command. The argument list was already
present in vi, the file list is new in Vim. The file names in the argument
list will also be present in the file list (unless they were deleted with
":bdel").

You can use the argument list with the following commands:

:ar[gs]			Print the argument list, with the current file in
			square brackets.

:[count]argu[ment] [count] [+cmd]
			Edit file [count] in the argument list, unless
			changes have been made and the 'autowrite' option is
			off. {Vi: no such command}

:[count]argu[ment]! [count] [+cmd]
			Edit file [count] in the argument list, discard any
			changes to the current buffer. {Vi: no such command}

:[count]n[ext] [+cmd]	Edit [count] next file, unless changes have been 
			made and the 'autowrite' option is off {Vi: no 
			count}.

:[count]n[ext]! [+cmd]	Edit [count] next file, discard any changes to the 
			buffer {Vi: no count}.

:ar[gs] [+cmd] {filelist}
:n[ext] [+cmd] {filelist}
			Define {filelist} as the new argument list and edit
			the first one, unless changes have been made and the
			'autowrite' option is off.

:ar[gs]! [+cmd] {filelist}
:n[ext]! [+cmd] {filelist}
			Define {filelist} as the new argument list and edit
			the first one. Discard any changes to the buffer.

:[count]N[ext] [count] [+cmd]
			Edit [count] previous file in argument list, unless 
			changes have been made and the 'autowrite' option is 
			off {Vi: no count}.

:[count]N[ext]! [count] [+cmd]
			Edit [count] previous file in argument list. Discard
			any changes to the buffer {Vi: no count}.

:[count]pre[vious] [count] [+cmd]
			Same as :Next {Vi: only in some versions}

:rew[ind] [+cmd]	Start editing the first file in the argument list,
			unless changes have been made and the 'autowrite'
			option is off.

:rew[ind]! [+cmd]	Start editing the first file in the argument list.
			Discard any changes to the buffer.

:la[st] [+cmd]		Start editing the last file in the argument list, unless
			changes have been made and the 'autowrite' option is
			off. {not in Vi}

:la[st]! [+cmd]		Start editing the last file in the argument list.
			Discard any changes to the buffer. {not in Vi}

:[count]wn[ext] [+cmd]	Write current file and start editing the [count] 
			next file. {not in Vi}

:[count]wn[ext] [+cmd] {file}
			Write current file to {file} and start editing the
			[count] next file, unless {file} already exists and
			the 'writeany' option is off. {not in Vi}

:[count]wn[ext]! [+cmd] {file}
			Write current file to {file} and start editing the
			[count] next file. {not in Vi}

:[count]wN[ext][!] [+cmd] [file]
:[count]wp[revous][!] [+cmd] [file]
			Same as :wnext, but go to previous file instead of
			next. {not in Vi}

The [count] in the commands above defaults to one. For some commands it is
possible to use two counts. The last one (rightmost one) is used.

For [+cmd] see 5.2.

The wildcards in the argument list are expanded and the filenames are sorted.
Thus you can use the command "vim *.c" to edit all the C files. From within 
Vim the command ":n *.c" does the same.

You are protected from leaving Vim if you are not editing the last file in 
the argument list. This prevents you from forgetting that you were editing one 
out of several files. To exit anyway try to exit twice. If there are changes
in the current buffer this will fail. You can exit anyway, and save any
changes, with the ":wq!" command. To lose any changes use the ":q!" command.


5.4 Writing and quitting

:[range]w[rite][!]	Write the specified lines to the current file.

:[range]w[rite]	{file}	Write the specified lines to {file}, unless it
			already exists and the 'writeany' option is off.

:[range]w[rite]! {file}	Write the specified lines to {file}. Overwrite an
			existing file.

:[range]w[rite][!] >>	Append the specified lines to the current file.

:[range]w[rite][!] >> {file}
			Append the specified lines to {file}. <!> forces the
			write even if file does not exist.

:[range]w[rite] !{cmd}	Execute {cmd} with [range] lines as standard input
			(note the space in front of the <!>).

The default [range] for the ":w" command is the whole buffer (1,$).
If a file name is give with ":w" it becomes the alternate file. This can be
used when the write fails and you want to try again later with ":w #".


:q[uit] 		Quit, unless changes have been made or not editing 
			the last file in the argument list.

:q[uit]!		Quit always, without writing.

:cq			Quit always, without writing, and return an error 
			code. Used for Manx's QuickFix mode (see 5.5).

:wq			Write the current file. Exit if not editing the
			last file in the argument list.

:wq!			Write the current file and exit.

:wq {file}		Write to {file}. Exit if not editing the last
			file in the argument list.

:wq! {file}		Write to {file} and exit.

:x[it][!] [file]	Like ":wq", but write only when changes have been
			made.

:exi[t][!] [file]	Same as :xit.

ZZ			Write current file, if modified, and exit (same as
			":x").

If you write to an existing file (but do not append) while the 'backup' or 
'writebackup' option is on, a backup of the original file is made. On Unix 
systems the file is copied, on other systems the file is renamed. After the 
file has been successfully written and when the 'writebackup' option is on 
and the 'backup' option is off, the backup file is deleted.

'backup'	'writebackup'		action
   off		     off		no backup made
   off		     on			backup made, deleted afterwards
   on		     off		backup made, not deleted
   on		     on			backup made, not deleted (default)

On Unix systems:
When you write to an existing file, that file is truncated and then filled 
with the new text. This means that protection bits, owner and symbolic links 
are unmodified. The backup file however, is a new file, owned by the user 
who edited the file. If it is not possible to create the backup file in the 
same directory as the original file, the directory given with the 
'backupdir' option is used (default: home directory).

If the creation of a backup file fails, the write is not done. If you want 
to write anyway add a <!> to the command.

If the 'textmode' option is set <CR><LF> is used for end-of-line. This is
default for MSDOS. On other systems the message "[textmode]" is shown to
remind you that an usual end-of-line marker was used. If the 'textmode' is
not set LF is used for end-of-line. On MSDOS the message "[notextmode]" is
shown. See also the 'textmode' and 'textauto' options.


5.5 Using the QuickFix mode

Vim has a special mode to speedup the edit-compile-edit cycle. This is
inspired by the quickfix option of the Manx's Aztec C compiler on the Amiga.
The idea is to save the error messages from the compiler in a file and use
Vim to jump to the errors one by one. You can then examine each problem and
fix it, without having to remember all the error messages.

If you are using Manx's Aztec C compiler on the Amiga you should do the
following:
- Set the CCEDIT environment variable with the command
	mset "CCEDIT=vim -e"
- Compile with the -qf option. If the compiler finds any errors, Vim is 
  started and the cursor is positioned on the first error. The error message
  will be displayed on the last line. You can go to other errors with the
  commands mentioned below. You can fix the errors and write the file(s).
- If you exit Vim normally the compiler will re-compile the same file. If you
  exit with the :cq command, the compiler will terminate. Do this if you
  cannot fix the error, or if another file needs to be compiled first.

If you are using another compiler you should save the error messages in a
file and start Vim with "vim -e filename". An easy way to do this is with
the ":make" command (see below). The 'errorformat' option should be set to
match the error messages from your compiler (see below).

The following commands can be used if you are in QuickFix mode:

:cc [nr]		Display error [nr]. If [nr] is omitted, the same
			error is displayed again. {not in Vi}

:[count]cn		Display the [count] next error in the list that
			includes a file name. If there are no file names at
			all, go the the [count] next error. {not in Vi}

:[count]cp		Display the [count] previous error in the list that
			includes a file name. If there are no file names at
			all, go the the [count] previous error. {not in Vi}

:cq			Quit Vim with an error code, so that the compiler
			will not compile the same file again. {not in Vi}

:cf [errorfile]		Read the error file and jump to the first error.
			This is done automatically when Vim is started with
			the -e option. You can use this command when you
			keep Vim running while compiling. If you give the
			name of the errorfile, the 'errorfile' option will
			be set to [errorfile] {not in Vi}

:cl			List all errors. {not in Vi}

:make [arguments]	1. If the 'autowrite' option is set and the buffer
			   was changed, write it.
			2. Any existing 'errorfile' is deleted.
			3. The program given with the 'makeprg' option is
			   started (default "make") with the optional
			   [arguments] and the output is saved in
			   'errorfile' (for Unix it is also echoed on the
			   screen).
			4. The 'errorfile' is then read and the first error
			   is jumped to.
			5. The 'errorfile' is deleted.
			{not in Vi}

The name of the file can be set with the 'errorfile' option. The default is 
"AztecC.Err" for the Amiga and "errors" for other systems. The format of the
file from the Aztec compiler is:

	filename>linenumber:columnnumber:errortype:errornumber:errormessage

	filename	name of the file in which the error was detected
	linenumber	line number where the error was detected
	columnnumber	column number where the error was detected
	errortype	type of the error, normally a single <E> or <W>
	errornumber	number of the error (for lookup in the manual)
	errormessage	description of the error

Another compiler is likely to use a different format. You should set the
'errorformat' option to a scanf-like string that describes the format. First
you need to know how scanf works. Look in the documentation of your C
compiler. Vim will understand eight conversion characters. Others are invalid.
	%f		file name (finds a string)
	%l		line number (finds a number)
	%c		column number (finds a number)
	%t		error type (finds a single character)
	%n		error number (finds a number)
	%m		error message (finds a string)
	%*<conv>	any scanf non-assignable conversion
	%%		the single <%> character

Examples:
"%f>%l:%c:%t:%n:%m"			for the AztecC.Err file
"%f:%l:\ %t%*[^0123456789]%n:\ %m"	for Aztec C error messages
"%f\ %l\ %t%*[^0123456789]%n:\ %m"	for SAS C
"\"%f\",%*[^0123456789]%l:\ %m"		default for generic C compilers
"%f:%l:%m"				for GCC

Note the backslash in front of a space and double quote. It is required for
the :set command.

The "%f" and "%m" conversions have to detect the end of the string. They
should be followed by a character that cannot be in the string. Everything
up to that character is included in the string. Be careful: "%f%l" will
include everything up to the first <%> in the file name. If the "%f" or "%m"
is at the end, everything up to the end of the line is included.

If a line is detected that does not completely match the 'errorformat', the
whole line is put in the error message and the entry is marked "not valid"
These lines are skipped with the ":cn" and ":cp" commands (unless there is
no valid line at all). You can use ":cl" to display all the error messages.

If the error format does not contain a file name Vim cannot switch to the
correct file. You will have to do this by hand.

If you have a compiler that produces error messages that do not fit in the
format string, you could write a program that translates the error messages
into this format. You can use this program with the ":make" command by
changing the 'makeprg' option. For example:
	":set mp=make\ \\\|&\ error_filter".
The backslashes before the pipe character are required to avoid it to be
recognized as a command separator. The backslash before each space is
required for the set command.

The ":make" command executes the command given with the 'makeprg' option.
This is done by passing the command to the shell given with the 'shell'
option. This works almost like typing

	":!{makeprg} [arguments] {shellpipe} {errorfile}".

{makeprg} is the string given with the 'makeprg' option. Any command can be
used, not just "make". Characters <%> and <#> are expanded as usual on a
command line. You can use "#<" to insert the current filename without
extension, for example ":set makeprg=make\ #<.o".

[arguments] is anything that is typed after ":make".
{shellpipe} is the 'shellpipe' option.
{errorfile} is the 'errorfile' option.

The 'shellpipe' option defaults to ">" for the Amiga and MSDOS. This means
that the output of the compiler is saved in a file and not shown on the
screen directly. For Unix "| tee" is used. The compiler output is shown on
the screen and saved in a file the same time. Depending on the shell used
"|& tee" or "2>&1| tee" is the default, so stderr output will be included.

There are some restrictions to the Quickfix mode on the Amiga. The
compiler only writes the first 25 errors to the errorfile (Manx's
documentation does not say how to get more). If you want to find the others,
you will have to fix a few errors and exit the editor. After recompiling,
up to 25 remaining errors will be found.

On the Amiga, if Vim was started from the compiler, the :sh and :! commands
will not work, because Vim is then running in the same process as the
compiler and these two commands may guru the machine then.

If you insert or delete lines, mostly the correct error location is still 
found because hidden marks are used (Manx's Z editor does not do this). 
Sometimes, when the mark has been deleted for some reason, the message "line 
changed" is shown to warn you that the error location may not be correct. If 
you quit Vim and start again the marks are lost and the error locations may
not be correct anymore.


5.6 Editing binary files

Although Vim was made to edit text files, it is possible to edit binary
files. The "-b" command line option (b for binary) sets some options for
editing binary files ('binary' on, 'textwidth' to 0, 'textmode' and
'textauto' off, 'modelines' to 0, 'expandtab' off). Setting the 'binary'
option has the same effect. Don't forget to do this before reading the file.

There are a few things to remember when editing binary files:
- When editing executable files the number of characters must not change.
  Use only the "R" or "r" command to change text. Do not delete characters
  with "x" or by backspacing.
- Set the 'textwidth' option to 0. Otherwise lines will unexpectedly be
  split in two.
- When there are not many end-of-line characters, the lines will become very
  long. If you want to edit a line that does not fit on the screen reset the
  'wrap' option. Horizontal scrolling is used then. If a line becomes too
  long (more than about 32767 characters on the Amiga, much more on 32-bit
  systems) you cannot edit that line. The line will be split when reading
  the file. It is also possible that you get an "out of memory" error when
  reading the file.
- Make sure the 'textmode' and 'textauto' options are off before loading the
  file. In 'textmode' both <CR><LF> and <LF> are considered to end a line
  and when the file is written the <LF> will be replaced by <CR><LF>. The
  'modelines' option should also be off, because there may be a string like
  ":vi:" in the file that would give unpredictable results.
- <NUL> characters are shown on the screen as ^@. You can enter them with
  "CTRL-V CTRL-@" or "CTRL-V 000" {vi cannot handle <NUL> characters in the
  file}
- To insert a <LF> character in the file split up a line. When writing the
  buffer to a file a <LF> will be written for the end of line.
- Vim normally appends an end-of-line character at the end of the file if
  there is none. Setting the 'binary' option prevents this. If you want to
  add the final end-of-line, set the 'endofline' option. You can also read the
  value of this option to see if there was an end-of-line character for the
  last line (you cannot see this in the text).


	6. Cursor motions

These commands move the cursor position. If the new position is off of the
screen, the screen is scrolled to show the cursor (see also 'scrolljump' 
option).

The motion commands can be used after other commands, called operators, to
have the command operate on the text that was moved over. That is the text
between the cursor position before and after the motion. If the motion
includes a count and the operator also had a count, the two counts are
multiplied. For example: "2d3w" deletes six words.
	The operator either affects whole lines, or the characters between 
the start and end position. Generally, motions that move between lines
affect lines (are linewise), and motions that move within a line affect
characters. However, there are some exceptions.
	A character motion is either inclusive or exclusive. When inclusive,
the start and end position of the motion are included in the operation.
When exclusive, the last character towards the end of the buffer is not
included. Linewise motions always include the start and end position.
	Which motions are linewise, inclusive or exclusive is mentioned 
below. There are however, two general exceptions:
1. If the motion is exclusive and the end of the motion is in column 1, the 
   end of the motion is moved to the end of the previous line and the motion 
   becomes inclusive. Example: "}" ends at the first line after a paragraph, 
   but "V}" will not include that line.
2. If the motion is exclusive, the end of the motion is in column 1 and the 
   start of the motion was at or before the first non-blank in the line, the 
   motion becomes linewise. Example: If a paragraph begins with some blanks 
   and you do "d}" while standing on the first non-blank, all the lines of 
   the paragraph are deleted, including the blanks. If you do a put now, the 
   deleted lines will be inserted below the cursor position.

Instead of first giving the operator and then a motion you can use Visual
mode: mark the start of the text with <v>, move the cursor to the end of the
text that is to be affected and then hit the operator. The text between the
start and the cursor position is highlighted, so you can see what text will
be operated upon. This allows much more freedom, but requires more key
strokes and has limited redo functionality. See the chapter on Visual mode.

If you want to know where you are in the file use the "CTRL-G" command. If 
you set the 'ruler' option, the cursor position is continuously shown in the 
status line (which slows down Vim a little).

NOTE: Experienced users prefer the hjkl keys because they are always right
under their fingers. Beginners often prefer the arrow keys, because they
do not know what the hjkl keys do. The mnemonic value of hjkl is clear from
looking at the keyboard. Think of j as an arrow pointing downwards.

6.1 Left-right motions

h		or
<C_LEFT>	or
CTRL-H		or
<BS>			[count] characters to the left (exclusive).

l		or
<C_RIGHT>	or
<SPACE>			[count] characters to the right (exclusive).

0			To the first character of the line (exclusive).

^			To the first non-blank character of the line
			(exclusive).

$			To the end of line [count] from the cursor
			(inclusive).

|			To column [count] (inclusive).

f<char>			To [count]'th occurrence of <char> to the right. The
			cursor is placed on <char> (inclusive).

F<char>			To the [count]'th occurrence of <char> to the left.
			The cursor is placed on <char> (inclusive).

t<char>			Till before [count]'th occurrence of <char> to the
			right. The cursor is placed on the character left of 
			<char> (inclusive).

T<char>			Till after [count]'th occurrence of <char> to the
			left. The cursor is placed on the character right of
			<char> (inclusive).

;			Repeat latest f, t, F or T [count] times.

,			Repeat latest f, t, F or T in opposite direction
			[count] times.

These commands move the cursor to the specified column in the current line.
They stop at the first column and at the end of the line, except "$", which 
may move to one of the next lines.


6.2 Up-down motions

k		or
<C_UP>		or
CTRL-P			[count] lines upward (linewise).

j		or
<C_DOWN>	or
CTRL-J		or
<LF>		or
CTRL-N			[count] lines downward (linewise).

-  <minus>		[count] lines upward, on the first non-blank
			character (linewise).

+		or
CTRL-M		or
<CR>			[count] lines downward, on the first non-blank
			character (linewise).

_  <underscore>		[count] - 1 lines downward, on the first non-blank
			character (linewise).

G			Goto line [count], default last line, on the first
			non-blank character (linewise).

:[range]		Set the cursor on the (last) specified line number
			(cannot be used with an operator).

{count}%		Go to {count} percentage in the file, on the first
			non-blank in the line (linewise). To compute the new
			line number this formula is used: {count} *
			number-of-lines / 100. {not in Vi}

These commands move to the specified line. They stop when reaching the first 
or the last line. The first two commands put the cursor in the same column 
(if possible) as it was after the last command that changed the column, 
except after the "$" command, then the cursor will be put on the last 
character of the line.


6.3 Word motions

<SC_RIGHT>	or
w			[count] words forward (exclusive).

W			[count] WORDS forward (exclusive).

e			Forward to the end of word [count] (inclusive).

E			Forward to the end of WORD [count] (inclusive).

<SC_LEFT>	or
b			[count] words backward (exclusive).

B			[count] WORDS backward (exclusive).

These commands move over words or WORDS. A word consists of a sequence of 
letters, digits and underscores, or a sequence of other non-blank 
characters, separated with white space (spaces, tabs, end of line). A WORD
consists of a sequence of non-blank characters, separated with white space.
An empty line is also considered to be a word and a WORD.

Special case: "cw" and "cW" are treated like "ce" and "cE" if the cursor is 
on a non-blank. This is because "cw" is interpreted as change-word, and a 
word does not include the following white space. {Vi: "cw" when on a blank 
followed by other blanks changes only the first blank; this is probably a 
bug, because "dw" deletes all the blanks}

Another special case: When using the "w" motion in combination with an 
operator and the last word moved over is at the end of a line, the end of 
that word becomes the end of the operated text, not the first word in the 
next line.

The original vi implementation of "e" is buggy. For example, the "e" command 
will stop on the first character of a line if the previous line was empty. 
But when you use "2e" this does not happen. In Vim "ee" and "2e" are the 
same, which is more logical. However, this causes a small incompatibility 
between vi and Vim.


6.4 Text object motions

(			[count] sentences backward (exclusive).

)			[count] sentences forward (exclusive).

{			[count] paragraphs backward (exclusive).

}			[count] paragraphs forward (exclusive).

]]			[count] sections forward or to the next <{> in the
			first column. When used after an operator, then the
			<}> in the first column. (linewise).

][			[count] sections forward or to the next <}> in the
			first column (linewise).

[[			[count] sections backward or to the previous <{> in
			the first column (linewise).

[]			[count] sections backward or to the previous <}> in
			the first column (linewise).

These commands move over three kinds of text objects.

A sentence is defined as ending at a <.>, <!> or <?> followed by either the 
end of a line, or by a space. {Vi: two spaces} Any number of closing <)>, 
<]>, <"> and <'> characters my appear after the <.>, <!> or <?> before the 
spaces or end of line. A paragraph and section boundary is also a sentence 
boundary.

A paragraph begins after each empty line, and also at each of a set of 
paragraph macros, specified by the pairs of characters in the 'paragraphs' 
option. The default is "IPLPPPQPP LIpplpipbp", which corresponds to the 
macros ".IP", ".LP", etc. (these are nroff macros, the dot must be in the 
first column). A section boundary is also a paragraph boundary. Note that
this does not include a <{> or <}> in the first column.

A section begins after a form-feed in the first column and at each of a set
of section macros, specified by the pairs of characters in the 'sections'
option. The default is "SHNHH HUnhsh".

The "]" and "[" commands stop at the <{> or <}" in the first column. This is
useful to find the start or end of a function in a C program. Note that the
first character of the command determines the search direction and the
second character the type of brace found.


6.5 Pattern searches

/{pattern}[/]		Search forward for the [count]'th occurrence of
			{pattern} (exclusive).

/{pattern}/{offset}	Search forward for the [count]'th occurrence of
			{pattern} and go {offset} lines up or down (see 
			below). (linewise).

/			Search forward for the [count]'th latest used
			pattern with latest used {offset}.

//{offset}		Search forward for the [count]'th latest used
			pattern with new {offset}. If {offset} is empty no
			offset is used.

*			Search forward for the [count]'th occurrence of the
			ident after or under the cursor (exclusive). Only
			whole words are search for, like with the command
			"/\<indent\>". If there is no identifier after or
			under the cursor, any non-blank word is used to
			search for. {not in Vi}

#			Same as "*", but search backward. {not in Vi}

?{pattern}[?]		Search backward for the [count]'th previous
			occurrence of {pattern} (exclusive).

?{pattern}?{offset}	Search backward for the [count]'th previous
			occurrence of {pattern} and go {offset} lines up or
			down (see below) (linewise).

?			Search backward for the [count]'th latest used
			pattern with latest used {offset}.

??{offset}		Search backward for the [count]'th latest used
			pattern with new {offset}. If {offset} is empty no
			offset is used.

n			Repeat the latest "/" or "?" [count] times. {Vi: no
			count}

N			Repeat the latest "/" or "?" [count] times in
			opposite direction. {Vi: no count}

CTRL-C			Interrupt current (search) command.

These commands search for the specified pattern. With "/" and "?" an 
additional offset may be given. There are two types of offsets: line offsets 
and character offsets. {the character offsets are not in Vi}

The offset gives the cursor position relative to the found match:
    [num]	[num] lines downwards, in column 1
    +[num]	[num] lines downwards, in column 1
    -[num]	[num] lines upwards, in column 1
    e[+num]	[num] characters to the right of the end of the match
    e[-num]	[num] characters to the left of the end of the match
    s[+num]	[num] characters to the right of the start of the match
    s[-num]	[num] characters to the left of the start of the match
    b[+num]	[num] characters to the right of the start (begin) of the match
    b[-num]	[num] characters to the left of the start (begin) of the match

If a <-> or <+> is given but [num] is omitted, a count of one will be used.
When including an offset with 'e', the search becomes inclusive (the
character the cursor lands on is included in operations).

Examples:

pattern			cursor position
/test/+1		one line below "test", in column 1
/test/e			on the last t of "test"
/test/s+2		on the <s> of "test"
/test/b-3		three characters before "test"

If one of these commands is used after an operator, the characters between 
the cursor position before and after the search is affected. However, if a 
line offset is given, the whole lines between the two cursor positions are 
affected.

The last used <pattern> and <offset> are remembered. They can be used to
repeat the search, possibly in another direction or with another count. Note
that two patterns are remembered: one for 'normal' search commands and one
for the substitute command ":s". Each time an empty <pattern> is given, the
previously used <pattern> is used.

{In vi the :tag command sets a new search pattern when the tag is searched
for. In Vim this is not done, the previous search pattern is still
remembered}.

If the 'wrapscan' option is set (which is the default), searches wrap around 
the end of the buffer. If 'wrapscan' is not set, the backward search stops 
at the beginning and the forward search stops at the end of the buffer. If 
'wrapscan' is set and the pattern was not found the error message "pattern
not found" is given, and the cursor will not be moved. If 'wrapscan' is not
set the message becomes "search hit BOTTOM without match" when searching
forward, or "search hit TOP without match" when searching backward. If
wrapscan is set and the search wraps around the end of the file the message
"search hit TOP, continuing at BOTTOM" or "search hit BOTTOM, continuing at
TOP" is given when searching backwards or forwards respectively.

The "*" and "#" commands search for the identifier currently under the
cursor. If there is no identifier under the cursor, the first one to the
right is used. This identifier may only contain letters, digits and
underscores. Note that if you type with ten fingers, the characters are easy
to remember: the "#" is under your left hand middle finger (search to the
left and up) and the "*" is under your right hand middle finger (search to
the right and down). If there is no identifier under or after the cursor, a
search is done for any word under or after the cursor. Blanks (<TAB>s and/or
<SPACE>s) are recognized as delimiters for this word.


The definition of a pattern:

Patterns may contain special characters, depending on the setting of the
'magic' option.

1.  A pattern is one or more branches, separated by '\|'. It matches anything
    that matches one of the branches. Example: "foo\|bar" matches "foo" and
    "bar.

2.  A branch is one or more pieces, concatenated. It matches a match for the
    first, followed by a match for the second, etc. Example: "foo[0-9]bar",
    first match "foo", then a digit and then "bar".

3.  A piece is an atom, possibly followed by:
      'magic'	'nomagic'
      option    option
	*	  \*		matches 0 or more of the preceding atom
	\+	  \+		matches 1 or more of the preceding atom {not
				in Vi}
	\=	  \=		matches 0 or 1 of the preceding atom {not in
				Vi}
    Examples:
       .*	  .\*		match anything, also empty string
       .\+	  .\+		match any non-empty string
       foo\=	  foo\=		match "fo" and "foo"


4.  An atom can be:
    - One of these five:
      magic	nomagic
	.	  \.		matches any single character
	\<	  \<		matches the beginning of a word
	\>	  \>		matches the end of a word
	^	  ^		at beginning of pattern, matches start of
				line
	$	  $		at end of pattern or in front of '\|',
				matches end of line
    - A pattern enclosed by escaped parentheses (e.g. "\(^a\)").
    - A single character, with no special meaning, matches itself
    - A backslash followed by a single character, with no special meaning,
      matches the single character.
    - A range. This is a sequence of characters enclosed in '[]' with the 
      'magic' option, or enclosed in '\[]' with the 'nomagic' option. It 
      normally matches any single character from the sequence. If the 
      sequence begins with <^>, it matches any single character NOT in the 
      sequence. If two characters in the sequence are separated by <->, this 
      is shorthand for the full list of ASCII characters between them (e.g. 
      '[0-9]' matches any decimal digit). To include a literal <]> in the 
      sequence, make it the first character (following a possible <^>). To 
      include a literal '\-', make it the first or last character.

If the 'ignorecase' option is set, the case of letters is ignored.

It is impossible to have a pattern that contains a line break.

Examples:
^beep(			Probably the start of the C function "beep".

[a-zA-Z]$		Any alphabetic character at the end of a line.

\(^\|[^a-zA-Z0-9_]\)[a-zA-Z_]\+[a-zA-Z0-9_]*
			A C identifier (will stop in front of it).

\(\.$\|\. \)		A period followed by end-of-line or a space.
			Note that "\(\. \|\.$\)" does not do the same,
			because '$' is not end-of-line in front of '\)'.
			This was done to remain vi-compatible.

[.!?][])"']*\($\|[ ]\)	A search pattern that finds the end of a sentence,
			with almost the same definition as the <)> command.

Technical detail:
<NUL> characters in the file are stored as <LF> in memory. In the display
they are shown as "^@". The translation is done when reading and writing
files. To match a <NUL> with a search pattern you can just enter CTRL-@ or
"CTRL-V 000". This is probably just what you expect. Internally the
character is replaced by a <LF> in the search pattern. What is unusual is
that typing CTRL_V CTRL_J also inserts a <LF>, thus also searches for a
<NUL> in the file. {vi cannot handle <NUL> characters in the file at all}


6.6 Various motions

m<a-zA-Z>		Set mark <a-zA-Z> at cursor position (does not move 
			the cursor, this is not a motion command).

:[range]mar[k] <a-zA-Z>	Set mark <a-zA-Z> at last line number in [range], 
			column 0. Default is cursor line.

:[range]k<a-zA-Z>	Same as :mark, but the space before the mark name can
			be omitted.

'<a-z>			To the first non-blank character on the line with
			mark <a-z> (linewise).

'<A-Z>			To the first non-blank character on the line with
			mark <A-Z> in the correct file (linewise when in 
			same file, not a motion command when in other file). 
			{not in Vi}

`<a-z>			To the mark <a-z> (exclusive).

`<A-Z>			To the mark <A-Z> in the correct file (exclusive 
			when in same file, not a motion command when in 
			other file). {not in Vi}

:marks			List the current marks (not a motion command). {not 
			in Vi}

A mark is not visible in any way. It is just a position in the file that is
remembered. Do not confuse marks with named registers, they are totally 
unrelated.

Lowercase marks are only remembered as long as the file remains loaded. If
you quit editing the file, change a character in a line or delete a line
that contains a mark, that mark is erased. Lowercase marks can be used
in combination with operators. For example: "d't" deletes the lines from the
cursor position to mark <t>. Hint: Use mark <t> for Top, <b> for Bottom,
etc..

Marks are restored when using undo and redo.

Marks are remembered as long as the file remains in the buffer list.

Uppercase marks include the file name. {Vi: no uppercase marks} You can use 
them to jump from file to file. You can only use an uppercase mark with 
an operator if the mark is in the current file. The line number of the mark
remains correct, even if you insert/delete lines or edit another file for a
moment.


'[			To the first non-blank character on the first line 
			of the previously operated text or start of the last 
			putted text. {not in Vi}

`[			To the first character of the previously operated 
			text or start of the last putted text. {not in Vi}

']			To the first non-blank character on the last line of 
			the previously operated text or end of the last 
			putted text. {not in Vi}

`]			To the last character of the previously operated 
			text or end of the last putted text. {not in Vi}

After executing an operator the Cursor is put at the beginning of the text 
that was operated upon. After a put command ("p" or "P") the cursor is 
sometimes placed at the first inserted line and sometimes on the last 
inserted character. The four commands above put the cursor at either
end. Example: After yanking 10 lines you want to go to the last one of them: 
"10Y']". After inserting several lines with the "p" command you want to jump 
to the lowest inserted line: "p']".

Note: After deleting text, the start and end positions are the same, except 
when using blockwise Visual mode. These commands do not work when no
operator or put command has been used yet in the current file. The position
may be incorrect after inserting text and ".p.


''			To the first non-blank character of the line where
			the cursor was before the latest jump (linewise).

``			To the position before latest jump (exclusive).

A "jump" is one of the following commands: "'", "`", "G", "/", "?", "n", 
"N", "%", "(", ")", "[[", "]]", "{", "}", ":s", ":tag", "L", "M", "H" and
the commands that start editing a new file. If you make the cursor "jump"
with one of these commands, the position of the cursor before the jump is
remembered. You can return to that position with the "''" and "``" command,
unless the line containing that position was changed or deleted.

CTRL-O			Go to [count] Older cursor position in jump list
			(not a motion command). {not in Vi}

CTRL-I			Go to [count] newer cursor position in jump list
			(not a motion command). {not in Vi}

:jumps			Print the jump list (not a motion command). {not in 
			Vi} 

Jumps are remembered in a jump list. With the CTRL-O and CTRL-I command you 
can go to cursor positions before older jumps, and back again. Thus you can 
move up and down the list.

For example, after three jump commands you have this jump list:

 jump line  file
   1     1  -current-
   2    70  -current-
   3  1154  -current-
>

You are currently in line 1167. If you then use the CTRL-O command, the 
cursor is put in line 1154. This results in:

 jump line  file
   1     1  -current-
   2    70  -current-
>  3  1154  -current-
   4  1167  -current-

The pointer will be set at the last used jump position. The next CTRL-O 
command will use the entry above it, the next CTRL-I command will use the 
entry below it. If the pointer is below the last entry, this indicates that 
you did not use a CTRL-I or CTRL-O before. In this case the CTRL-O command 
will cause the cursor position to be added to the jump list, so you can get 
back to the position before the CTRL-O. In this case this is line 1167.

With more CTRL-O commands you will go to lines 70 and 1. If you use CTRL-I 
you can go back to 1154 and 1167 again.

If you use a jump command, the current line number is inserted at the end of 
the jump list. If you used CTRL-O or CTRL-I just before that, the same line 
may be in the list twice. This may be a bit strange. Just try it and look at 
the jump list with the :jumps command. Note that this behaviour is different 
from the tag stack.

After the CTRL-O command that got you into line 1154 you could give another 
jump command (e.g. "G"). The jump list would then become:

 jump line  file
   1     1  -current-
   2    70  -current-
   3  1154  -current-
   4  1167  -current-
   5  1154  -current-
>

As long as you stay in the same file, the line numbers will be adjusted for 
deleted and inserted lines. If you go to another file the line numbers may 
be wrong (keeping them correct would take too much time). If you want to 
avoid this use a :jumps command before changing files. This will update the 
line numbers in the current file.

%			Find the next item in this line after or under the
			cursor and jump to its match (inclusive). Items can
			be:
			([{}])		parenthesis or (curly/square) brackets
			 /* */		start or end of C-style comment
			#if, #ifdef, #else, #elif, #endif
					C preprocessor conditionals
			Parens and braces preceded with a backslash are
			ignored. Parens and braces inside quotes are ignored,
			unless the number of parens/braces in a line is uneven
			and this line and the previous one does not end in a
			backslash. No count is allowed ({count}% jumps to a
			line {count} percentage down the file).
			Using '%' on #if/#else/#endif makes the movement
			linewise.

[(			go to [count] previous unmatched <(>. {not in Vi}

[{			go to [count] previous unmatched <{>. {not in Vi}

])			go to [count] next unmatched <)>. {not in Vi}

]}			go to [count] next unmatched <}>. {not in Vi}

The above four commands can be used to go to the start or end of the current
code block. It is like doing "%" on the <(>, <)>, <{> or <}> at the other
end of the code block, but you can do this from anywhere in the code block.
Very useful for C programs. Example: When standing on "case x:", "[{" will
bring you back to the switch statement.

H			To line [count] from top (Home) of screen (default:
			first line on the screen) on the first non-blank 
			character (linewise).

M			To Middle line of screen, on the first non-blank
			character (linewise).

L			To line [count] from bottom of screen (default: Last
			line on the screen) on the first non-blank character 
			(linewise).


	7. Scrolling

Move edit window downwards (this means that more lines downwards in the text
buffer are seen):

CTRL-E			Window [count] lines downwards in the buffer

CTRL-D			Window Downwards in the buffer. The number of lines
			comes from the 'scroll' option (default: half a
			screen). If [count] given, first set 'scroll' option
			to [count].

<SC_DOWN>	or
CTRL-F			Window [count] pages Forwards (downwards) in the
			buffer.

Move edit window upwards (this means that more lines upwards in the text
buffer are seen): 

CTRL-Y			Window [count] lines upwards in the buffer.

CTRL-U			Window Upwards in the buffer. The number of lines
			comes from the 'scroll' option (default: half a
			screen). If [count] given, first set 'scroll' option
			to [count].

<SC_UP>		or
CTRL-B			Window [count] pages Backwards (upwards) in the
			buffer.

Window repositioning:

z<CR>			Redraw, line [count] at top of window (default
			cursor line). Put cursor at first non-blank in the
			line.

zt			Like "z<CR>", but leave the cursor in the same
			column. {not in Vi}

z{height}<CR>		Redraw, make window {height} lines tall. This is
			useful to make the number of lines small when screen
			updating is very slow. Cannot make the height more
			than the physical screen height.

z.			Redraw, line [count] at center of window (default 
			cursor line). Put cursor at first non-blank in the
			line.

zz			Like "z.", but leave the cursor in the same column.
			{not in Vi}

z-			Redraw, line [count] at bottom of window (default 
			cursor line). Put cursor at first non-blank in the
			line.

zb			Like "z-", but leave the cursor in the same column.
			{not in Vi}

These commands move the contents of the window. If the cursor position is 
moved off of the window, the cursor is moved onto the window. A page is the 
number of lines in the window minus two. The mnemonics for these commands 
may be a bit confusing. Remember that the commands refer to moving the 
window upwards or downwards in the buffer. But when the window moves upwards 
in the buffer, the text in the window moves downwards on your screen.


	8. Tags

:ta[g][!] {ident}	Jump to the definition of {ident}, using the
			information in the tags file. Put {ident} in the tag
			stack. See below for [!].

CTRL-]			":ta" to the identifier under or after cursor. Put 
			the identifier in the tag stack. {Vi: identifier 
			after the cursor}

CTRL-T			Jump to [count] older entry in the tag stack
			(default 1). {not in Vi}

:[count]po[p][!]	Jump to [count] older entry in tag stack (default 1).
			See below for [!]. {not in Vi}

:[count]ta[g][!]	Jump to [count] newer entry in tag stack (default 1).
			See below for [!]. {not in Vi}

:tags			Show the contents of the tag stack. The active
			entry is marked with a <>>. {not in Vi}

A tag is an identifier that appears in the "tags" file. It is a sort of label
that can be jumped to. For example: In C programs each function name can be 
used as a tag.

With the ":tag" command the cursor will be positioned on the tag. With the
CTRL-] command, the identifier on which the cursor is standing is used as the
tag. If the cursor is not on an identifier, the first identifier rightwards 
of the cursor is used.

The 'ignorecase' option can be used to make the tag search case insensitive.

If the tag is in the current file this will always work. Otherwise the
performed actions depend on whether the current file was changed, whether a !
is added to the command and on the 'autowrite' option:

  tag in       file        autowrite
current file  changed   !   option	  action
-----------------------------------------------------------------------------
    yes		 x	x     x	  goto tag
    no		 no	x     x	  read other file, goto tag
    no		yes    yes    x   abandon current file, read other file, goto
    				  tag
    no		yes	no    on  write current file, read other file, goto
    				  tag
    no		yes	no   off  fail
-----------------------------------------------------------------------------

- If the tag is in the current file, the command will always work.
- If the tag is in another file and the current file was not changed, the 
  other file will be made the current file and read into the buffer.
- If the tag is in another file, the current file was changed and a ! is 
  added to the command, the changes to the current file are lost, the other 
  file will be made the current file and read into the buffer.
- If the tag is in another file, the current file was changed and the 
  'autowrite' option is set, the current file will be written, the other 
  file will be made the current file and read into the buffer.
- If the tag is in another file, the current file was changed and the 
  'autowrite' option is not set, the command will fail. If you want to save 
  the changes, use the ":w" command and then use ":tag" without an argument. 
  This works because the tag is put on the stack anyway. If you want to lose 
  the changes you can use the ":tag!" command.

The ":tag" command works very well for C programs. If you see a call to a
function and wonder what that function does, position the cursor inside of 
the function name and hit CTRL-]. This will bring you to the function 
definition. An easy way back is with the CTRL-T command. Also read about the 
tag stack below.

A tags file can be created with the external command 'ctags'. It will 
contain a tag for each function. Some versions of 'ctags' will also make a 
tag for each "#defined" macro.

The lines in the tags file should have this format:

	{tag}{separator}{filename}{separator}{command}

{tag}		the identifier
{separator}	one or more <TAB> or space characters
{filename}	the file that contains the definition of {tag}
{command}	the Ex command that positions the cursor on the tag.

The command can be any Ex command, but normally it is a search command like 
"/^main(argc, argv)". If it is a search command, and the search fails,
another try is done to search for "^main(" (the tag with <^> prepended and
<)> appended). When using function names, this will find the function name
when it is in column 0. This will help when the arguments to the function
have changed since the tags file was made. If this search also fails another
try is done with "^[#a-zA-Z_].*main(". This means: A line starting with <#>
or an identifier and containing the tag followed by <(>. This will find
macro names and function names with a type prepended. {the two extra
searches are not in vi}.

{In vi the :tag command sets a new search pattern when the tag is searched
for. In Vim this is not done, the previous search pattern is still
remembered. The search pattern for the tag is not remembered.}.


The 'tags' option is a list of file names separated by spaces. Each of these 
files is searched for the tag. This can be used to use a different file than 
the default file "tags". It can also be used to access a common tags file. 
For example:

:set tags=tags\ /home/user/commontags

The tag will first be searched for in the file "tags" in the current
directory. If it is not found there the file "/home/user/commontags" will be
searched for the tag. The backslash is required for the space to be included
in the string option.

If the 'tagrelative' option is set (which is the default) and using a tag file
in another directory, file names in that tag file are relative to the
directory where the tag file is.


The tags that you use are remembered in the tag stack. You can print this 
stack with the ":tags" command. The result looks like this:

  # TO tag      FROM line in file
  1 main               1  harddisk2:text/vim/test
> 2 FuncA             58  -current-
  3 FuncC            357  harddisk2:text/vim/src/amiga.c

This list shows the tags that you jumped to and the cursor position before that 
jump. The older tags are at the top, the newer at the bottom.

The <>> points to the active entry. This is the tag that will be used by the 
next ":tag" command. The CTRL-T and ":pop" command will use the position 
above the active entry.

The line number and file name are remembered to be able to get back to where 
you were before the tag command. The line number will be correct, also when
deleting/inserting lines, unless this was done by another program (e.g.
another instance of Vim).

You can jump to previously used tags with several commands. Some examples:

	":pop" or CTRL-T 	to position before previous tag
	{count}CTRL_T		to position before {count} older tag
	":tag"			to newer tag
	":0tag" 		to last used tag

The most obvious way to use this is while browsing through the call graph of 
a program. Consider the following call graph:

	main  --->  FuncA  --->  FuncC
	      --->  FuncB

(Explanation: main calls FuncA and FuncB; FuncA calls FuncC).
You can get from main to FuncA by using CTRL-] on the call to FuncA. Then 
you can CTRL-] to get to FuncC. If you now want to go back to main you can 
use CTRL-T twice. Then you can CTRL-] to FuncB.

If you issue a ":ta {ident}" or CTRL-] command, this tag is inserted at the
current position in the stack. If the stack was full (it can hold up to 20
entries), the oldest entry is deleted and the older entries shift one
position up (their index number is decremented by one). If the last used
entry was not at the bottom, the entries below the last used one are
deleted. This means that an old branch in the call graph is lost. After the
commands explained above the tag stack will look like this:

  # TO tag      FROM line in file
  1 main               1  harddisk2:text/vim/test
  2 FuncB             59  harddisk2:text/vim/src/main.c
>


	9. Inserting text

The following commands can be used to insert new text into the buffer. They
can all be undone. The non-Ex commands can be repeated with the "." command.

a			Append text after the cursor [count] times.

A			Append text at the end of the line [count] times.

i			Insert text before the cursor [count] times.

I			Insert text before the first CHAR on the line
			[count] times.

o			Begin a new line below the cursor and insert text,
			repeat [count] times. {Vi: blank [count] screen
			lines}

O			Begin a new line above the cursor and insert text,
			repeat [count] times. {Vi: blank [count] screen
			lines}

These commands are used to start inserting text. They can be undone and
repeated. You can end Insert mode with <ESC>. See the section "Insert and
Replace mode" for the other special characters in Insert mode. The effect of
[count] takes place after Insert mode is exited.

:r[ead] [name]		Insert the file [name] (default: current file) below
			the cursor.

:{range}r[ead] [name]	Insert the file [name] (default: current file) below
			the specified line.

:r[ead] !{cmd}		Execute {cmd} and insert its standard output below
			the cursor.

These commands insert the contents of a file, or the output of a command, 
into the buffer. They can be undone. They cannot be repeated with the "." 
command. They work on a line basis, insertion starts below the line in which 
the cursor is, or below the specified line. To insert text above the first 
line use the command ":0r {name}".

The <LF> character is recognized as end-of-line marker. If the 'textmode'
option is set, a <CR> in front of an <LF> is ignored and a CTRL-Z at the end
of the file is ignored. The 'textmode' option is default on for MSDOS.

If the 'textauto' option is set Vim tries to recognize the type of
end-of-line marker (see 5.2 how this is done). However, the 'textmode'
option will not be changed. Only while reading one file the text mode is
used or not.

On non-MSDOS systems the message "[textmode]" is shown if a file is read in
text mode, to remind you that something unusual is done. On MSDOS the
message "[notextmode]" is shown if a file is read without text mode.


	10. Deleting text

["x]x			Delete [count] characters under and after the cursor
			[into register x] (not linewise).

["x]X			Delete [count] characters before the cursor [into
			register x] (not linewise).

["x]d{motion}		Delete text that is moved over [into register x]. 
			See below for exception.

["x]dd			Delete [count] lines [into register x] (linewise).

["x]D			Delete the characters under the cursor until the end
			of the line and [count]-1 more lines [into register 
			x]; synonym for d$ (not linewise).

{visual}["x]x	or
{visual}["x]d		Delete the highlighted text [into register x] (see
			the chapter on Visual mode). {not in Vi}

{visual}["x]X	or
{visual}["x]D		Delete the highlighted lines [into register x] (see
			the chapter on Visual mode). {not in Vi}

:[range]d[elete] [x]	Delete [range] lines (default: current line) [into
			register x].

:[range]d[elete] [x] {count}
			Delete {count} lines, starting with [range]
			(default: current line, see 4.4.4) [into register
			x].

These commands delete text. They can be repeated with the "." command
(except ":d") and undone. Use Visual mode to delete blocks of text. See
"Copying and moving text" for an explanation of registers.

An exception for the d{motion} command: If the motion is not linewise, the 
start and end of the motion are not in the same line and before the start 
and after the end are only blanks, the delete becomes linewise. This means 
that the blank line that would remain is also deleted.


J			Join [count] lines, with a minimum of two lines.

{visual}J		Join the highlighted lines, with a minimum of two
			lines. {not in Vi}

:[range]j[oin][!]	Join [range] lines. Same as "J", except when [!] is
			given, then no spaces will be inserted or deleted.
			When [range] is given and the start and end of the
			range are equal, nothing happens. Default is to join
			two lines.

:[range]j[oin][!] {count}
			Join {count} lines, starting with [range] (default:
			current line, see 4.4.4). Same as "J", except when
			[!] is given, then no spaces will be inserted or 
			deleted.

These commands delete the newline between lines. This has the effect of 
joining them into one line. They can be repeated (except ":j") and undone. 

One space is inserted in place of the <LF>, unless the line ended with a 
space, <TAB> or the next line started with a <)>. If the next line has 
leading white space it is deleted first. If the 'joinspaces' option is set, 
two spaces are inserted after a period.


	11. Changing text

The following commands can be used to change text, that is delete some text 
and insert something else, with one command. They can all be undone. The 
non-Ex commands can be repeated with the "." command.


11.1 Delete and insert

R			Enter Replace mode: Each character you type replaces
			an existing character, starting with the character
			under the cursor. Repeat the entered text [count]-1
			times.

["x]c{motion}		Delete {motion} text [into register x] and start
			insert.

["x]cc			Delete [count] lines [into register x] and start
			insert (linewise). If 'autoindent' is set, preserve
			the indent of the first line.

["x]C			Delete from the cursor position to the end of the
			line and [count]-1 more lines [into register x], and 
			start insert. Synonym for c$ (not linewise).

["x]s			Delete [count] characters [into register x] and start
			insert (s stands for Substitute). Synonym for "cl"
			(not linewise).

["x]S			Delete [count] lines [into register x] and start 
			insert. Synonym for "cc" (not linewise).

{visual}["x]c	or
{visual}["x]r	or
{visual}["x]s		Delete the highlighted text [into register x] and
			start insert (see the chapter on Visual mode). {not
			in Vi}

{visual}["x]C	or
{visual}["x]R	or
{visual}["x]S		Delete the highlighted lines [into register x] and
			start insert (see the chapter on Visual mode). {not
			in Vi}

You can end Insert and Replace mode with <ESC>. See the section "Insert and
Replace mode" for the other special characters in these modes. The effect of
[count] takes place after Insert or Replace mode is exited. {Vi: does not
directly delete the text, but puts a <$> at the last deleted character}
See "Copying and moving text" for an explanation of registers.

Replace mode is just like Insert mode, except that for every character you 
enter, one character is deleted. If the end of a line is reached, further 
characters are appended (just like Insert mode). In Replace mode the 
backspace key restores the original text (if there was any) (see section
"Insert and Replace mode").

Special case: "cw" and "cW" are treated like "ce" and "cE" if the cursor is 
on a non-blank. This is because "cw" is interpreted as change-word, and a 
word does not include the following white space. {Vi: "cw" when on a blank 
followed by other blanks changes only the first blank; this is probably a 
bug, because "dw" deletes all the blanks}


11.2 Simple changes

r<char>			Replace the character under the cursor by <char>. If
			<char> is a <CR> or <LF> the character will be
			replaced by a line break. If a [count] is given that
			many characters will be replaced by [count] <char>s
			or line breaks {Vi: "5r<CR>" replaces five
			characters with a single line break}

~			'notildeop' option: switch case of the character
			under the cursor and move the cursor to the right.
			If a [count] is given do that many characters {Vi:
			no count}

~{motion}		'tildeop' option: switch case of {motion} text. {Vi: 
			tilde cannot be used as an operator}

{visual}~		switch case of highlighted text (see the chapter on 
			Visual mode). {not in Vi}

{visual}U		Make highlighted text uppercase (see the chapter on 
			Visual mode). {not in Vi}

{visual}u		Make highlighted text lowercase (see the chapter on 
			Visual mode). {not in Vi}

CTRL-A			Add [count] to the number at or after the cursor.
			{not in Vi}

CTRL-X			Subtract [count] from the number at or after the 
			cursor. {not in Vi}

The CTRL-A and CTRL-X commands work for (signed) decimal numbers and 
unsigned octal and hexadecimal numbers. Numbers starting with '0x' or '0X' 
are assumed to be hexadecimal. To decide whether the hexadecimal number 
should be printed uppercase or not, the case of the rightmost letter in the 
number is considered. If there is no letter in the current number, the 
previously detected case is used. Numbers starting with a <0> are considered 
to be octal. Other numbers are decimal and may be preceded with a minus 
sign. If the cursor is on a number, that one will be used. Otherwise the 
number right of the cursor will be used.

The CTRL-A command is very useful in a macro. Example: How to make a 
numbered list.

1. Create the first entry. The entry should start with a number.
2. qa        - start recording into buffer <a>
3. Y         - yank the entry
4. p         - put a copy of the entry below the first one
5. CTRL-A    - increment the number
6. q         - stop recording
7. <count>@a - repeat the yank, put and increment <count> times


<{motion}		Shift the {motion} lines one shiftwidth leftwards.

<<			Shift [count] lines one shiftwidth leftwards.

{visual}<		Shift the highlighted lines [count] shiftwidth
			leftwards (see the chapter on Visual mode). {not in
			Vi} 

>{motion}		Shift {motion} lines one shiftwidth rightwards.

>>			Shift [count] lines one shiftwidth rightwards.

{visual}>		Shift the highlighted lines [count] shiftwidth
			rightwards (see the chapter on Visual mode). {not in
			Vi}

:[range]<		Shift [range] lines left. Repeat '<' for multiple
			shifts.

:[range]< {count}	Shift {count} lines left, starting with [range]
			(default current line, see 4.4.4). Repeat '<' for
			multiple shifts.

:[range]le[ft] [indent]	left align lines in [range]. Sets the indent in the
			lines to [indent] (default 0). {not in Vi}

:[range]>		Shift {count} [range] lines right. Repeat '>' for
			multiple shifts.

:[range]> {count}	Shift {count} lines right, starting with [range]
			(default current line, see 4.4.4). Repeat '>' for
			multiple shifts.

The ">" and "<" commands are handy for changing the indent within programs. 
The size of the white space which is inserted or deleted can be set with the 
'shiftwidth' option. Normally the 'shiftwidth' option is set to 8, but you 
can set it to e.g. 3 to make smaller indents. The shift leftwards stops when 
there is no indent. The shift right does not do anything with empty lines. 

If the 'shiftround' option is set, the indent is rounded to a multiple of 
'shiftwidth'.

If the 'smartindent' option is set, lines starting with <#> will not be
shifted right.

When the 'expandtab' option if off (this is the default) <TAB>s are used as 
much as possible to make the indent. You can use ">><<" to replace an indent 
made out of spaces with the same indent made out of <TAB>s (and a few 
spaces if necessary). If the 'expandtab' option is on, only spaces are 
used. Then you can use ">><<" to replace <TAB>s in the indent by spaces.

To move a line several 'shiftwidth's use the visual mode or the ":"
commands. For example:
	Vjj4>		move three lines 4 indents to the right
	:<<<		move current line 3 indents to the left
	:>> 5		move 5 lines 2 indents to the right


Q{motion}		Format the lines that were moved over. The length of 
			each line will be restricted to the width set with 
			the 'textwidth' option. If the 'textwidth' option is
			0, all lines will be joined together. If the
			'autoindent' option is set, the indent of the first
			line is used for the following lines. The
			'formatprg' option can be set to the name of an
			external program, which will be used instead of the
			internal function. The 'textwidth' option will then
			not be used. {not in Vi}

:[range]ce[nter] [width]
			Center lines in [range] between [width] columns
			(default 'textwidth' or 80 when 'textwidth' is 0).
			{not in Vi}

:[range]ri[ght] [width]
			right align lines in [range] at [width] columns
			(default 'textwidth' or 80 when 'textwidth' is 0).
			{not in Vi}


11.3 Complex changes

!{motion}{filter}	Filter {motion} text through the external program
			{filter}.

!!{filter}		Filter [count] lines through the external program
			{filter}.

{visual}!{filter}	Filter the highlighted lines through the external
			program {filter} (see the chapter on Visual mode).
			{not in Vi}

:{range}![!]{filter} [!][arg]
			Filter {range} lines through the external program
			{filter}. The optional bangs are replaced with the
			latest given command. The optional [arg] is appended.

={motion}		Filter {motion} lines through the external program 
			given with the 'equalprg' option (default: 
			"indent"). {Vi: when 'lisp' option is set, autoindent 
			{motion} lines}

==			Filter [count] lines through the external program
			given with the 'equalprg' option (default: indent).
			{not in Vi}

{visual}=		Filter the highlighted lines through the external
			program given with the 'equalprg' option (default:
			indent) (see the chapter on Visual mode). {not in
			Vi}

A filter is a program that accepts text at standard input, changes it in some
way, and sends it to standard output. The commands above can be used to send
some text through a filter. An example of a filter is "sort", which sorts 
lines alphabetically. The "indent" program is used to pretty indent C 
programs (you need a version of indent that works like a filter, not all 
versions do that). The shell, given with the 'shell' option, is used to 
execute the command (See also the 'shelltype' option).
The filter commands can be redone with ".". There cannot be a comment (with
<">) after the ":!" command.


:[range]s[ubstitute]/{pattern}/{string}/[g][c][r] [count]
			For each line in [range] replace {pattern} by
			{string}. See below for the flags.

:[range]s[ubstitute] [g][c][r] [count]
:[range]&[g][c][r] [count]
			Repeat last :substitute with same search pattern and
			substitute string. The flags may be different (see
			below).

:[range]~[g][c][r] [count]
			Repeat last substitute with same substitute string
			but with last used search pattern. This is like
			"&r". See explanation for [r] below.

&			Synonym for ":s//~/" (repeat last substitute).

The arguments that can be given to the substitute commands:
[g]	All occurrences in the line are replaced. Otherwise only the first
	occurrence in the line is replaced. If the 'edcompatible' option is
	set this flag is remembered and toggled each time it is used. It is
	reset when a new search pattern is given. If the 'gdefault' option
	is set, this flag is default on. Give the [g] to switch it on.
[c]	Each substitute has to be confirmed. The cursor is positioned on the
	matching string. You can type <y> to substitute, <n> to skip, <q> to
	quit substituting. If the 'edcompatible' option is set this flag is
	remembered and toggled each time it is used. It is reset when a new
	search pattern is given.
[r]	When the search pattern is empty use the previously used search
	pattern instead of the search pattern from the last substitute.
	If the last command that did a search was a substitute there is no
	effect. If the last command was another search command, like
	"/" or ":global", the pattern from that command is used.
[count] That many lines are are searched, starting with the last line number
	in [range] (default current line, see 4.4.4).

If the {pattern} for the substitute command is empty, the pattern from the
last substitute command is used. With the [r] flag the pattern from the last
substitute or search command ("/", ":global" and the like) is used.

Instead of the </> which surrounds the pattern and replacement string, you
can use any other character, but not an alphanumeric character, <"> or <|>
or <#>. This is useful if you want to include a </> in the search pattern or
replacement string. Example: ":s+/+//+"

For the definition of a pattern see 6.5, "Pattern searches".

Some characters in {string} have a special meaning:

magic	nomagic	  action
  &	  \&	  replaced by the whole matched pattern
 \&	   &	  replaced by &
      \0	  replaced by the whole matched pattern
      \1	  replaced by the matched pattern in the first pair of ()
      \2	  replaced by the matched pattern in the second pair of ()
      ..	  ..
      \9	  replaced by the matched pattern in the ninth pair of ()
  ~	  \~	  replaced by the {string} of the previous substitute
 \~	   ~	  replaced by ~
      \u	  next character made uppercase
      \U	  following characters made uppercase
      \l	  next character made lowercase
      \L	  following characters made lowercase
      \e	  end of /u, /U, /l and /L
      \E	  end of /u, /U, /l and /L
      <CR>	  split line in two at this point
  CTRL-V <CR>	  insert a carriage-return (CTRL-M)

Examples:
:s/a\|b/xxx\0xxx/g	      modifies "a b"	  in "xxxaxxx xxxbxxx"
:s/\([abc]\)\([efg]\)/\2\1/g  modifies "af fa bg" in "fa fa gb"
:s/abcde/abc^Mde/	      modifies "abcde"    in "abc", "de" (two lines)
:s/$/^V^M/		      modifies "abcde"	  in "abcde^M"

Note: To insert a ^M you have to type CTRL-V <CR>. To insert a ^V you have
to type CTRL-V CTRL-V. So to insert the ^V^M in the last example you have to
type CTRL-V CTRL-V CTRL-V <CR>.

Because CTRL-V <CR> inserts a <CR>, it is impossible to insert a CTRL-V just
in front of a line break. You will have to split it up in two parts:
	:s/foo/^Vxxxx/
	:s/xxxx/^M/

When using parentheses in combination with <|>, like in \([ab]\)\|\([cd]\), 
either the first or second pattern in parentheses did not match, so either 
\1 or \2 is empty. Example:
:s/\([ab]\)\|\([cd]\)/\1x/g   modifies "a b c d"  in "ax bx x x"


	12. Copying and moving text

"<a-zA-Z0-9.%:">	Use register <a-zA-Z0-9.%"> for next delete, yank or
			put (use uppercase character to append with delete
			and yank) (<.> only works with put).

:di[splay]		Display the contents of numbered and named registers.
			{Vi: no such command}

["x]y{motion}		Yank {motion} text [into register x].

["x]yy			Yank [count] lines [into register x] (linewise).

["x]Y			With 'noyankendofline' option: yank [count] lines 
			[into register x] (synonym for yy, linewise); with 
			'yankendofline' option: yank until end of line 
			(synonym for y$, not linewise).

{visual}["x]y		Yank the highlighed text [into register x] (see the 
			chapter on Visual mode). {not in Vi}

{visual}["x]Y		Yank the highlighted lines [into register x] (see the 
			chapter on Visual mode). {not in Vi}

:[range]y[ank] [x]	Yank [range] lines [into register x].

:[range]y[ank] [x] {count}
			Yank {count} lines, starting with last line number 
			in [range] (default: current line, see 4.4.4), [into 
			register x].

["x]p			Put the text [from register x] after the cursor
[count]
			times. {Vi: no count}

["x]P			Put the text [from register x] before the cursor
			[count] times. {Vi: no count}

:[line]pu[t] [x]	Put the text [from register x] after [line] (default
			current line).

:[line]pu[t]! [x]	Put the text [from register x] before [line] (default
			current line).

["x]]p			like "p", but adjust the indent to the current line.
			{not in Vi}

["x][p			like "P", but adjust the indent to the current line.
			{not in Vi}

These commands can be used to copy text from one place to another. This is 
done by first getting the text into a register with a yank, delete or change 
command. The register can then be inserted with a put command. All registers 
are kept when changing files. Thus you can also use this to move text from 
one file to another (the CTRL-^ command is a quick way to toggle between two 
files).

The put commands can be repeated with "." (except for :put) and undone. If the
command that was used to get the text into the register was linewise, the 
text will be inserted below ("p") or above ("P") the line where the cursor
is. Otherwise the text will be inserted after ("p") or before ("P") the
cursor. With the ":put" command the text will always be inserted in the next
line. You can exchange two characters with the command sequence "xp". You
can exchange two lines with the command sequence "ddp". You can exchange
two words with the command sequence "deep" (start with the cursor in the
blank space before the first word). The "']" or "`]" command can be used
after the put command to move the cursor to the end of the inserted text,
"'[" or "`[" to move the cursor to the start.

If the command that was used to get the text into the register used 
blockwise Visual mode, the block of text will be inserted before ("P") or
after ("p") the cursor column, in the current and next lines. Vim will make
the whole block of text start in the same column. Thus the inserted text
looks the same as when it was yanked or deleted. Some <TAB> characters may
be replaced by spaces to make this happen. However, if the width of the
block is not a multiple of a <TAB> width and the text after the inserted
block contains <TAB>s, that text may be misaligned.

There are four types of registers: The unnamed register, 10 numbered
registers, 26 named registers and two read-only registers.
	The unnamed register is the register where all text deleted with     
the "d", "c", "s", "x" commands or copied with the yank "y" command is
placed, regardless of whether or not a specific register was used (e.g.
"xdd). The contents of this register are used by any put command (p or P)
which does not specify a register. Additionally it can be accessed by the
name <">. This means you have to type two double quotes. {Vi: register
contents lost when changing files, no <">}
	The numbered registers are filled with yank and delete commands. 
Numbered register <0> is filled with the last yank command, unless another 
register was specified with ["x]. Numbered register <1> is filled with the 
text that was deleted by each delete or change command, unless another 
register was specified or the text is less than one line (text deleted with
"x" or "dw" will not be put in a numbered register). The contents of
register <1> are put in <2>, <2> in <3>, and so forth. The contents of
register <9> are lost. {Vi: numbered register contents are lost when
changing files; register 0 does not exist}
	The named registers are only filled when you say so. They are named 
<a> to <z> normally. If you use an uppercase letter, the same registers as 
with the lower case letter is used, but the text is appended to the previous 
register contents. With a lower case letter the previous contents are lost.
	The read-only registers are <%>, <:> and <.>. They can only be used
with the commands "p", "P" and ":put". <.> contains the last inserted
text (the same as what is inserted with the insert mode commands CTRL-A and
CTRL-@). <%> contains the name of the current file. <:> contains the last
command line, it can also be used with "@", "@:" repeats the last command
line.

If you use a put command without specifying a register, the register that 
was last written to is used (this is also the contents of the unnamed
register). If you are confused, use the ":dis" command to find out what will
be put (all named and numbered registers are displayed; the unnamed register
is labelled <">).

The next three commands always work on whole lines.

:[range]co[py] {address}
			Copy the lines given by [range] to below the line
			given by {address}.

:t			Synonym for copy.

:[range]m[ove] {address}
			Move the lines given by [range] to below the line
			given by {address}.


	13. Visual mode

Visual mode is a flexible and easy way to select a piece of text for an 
operator. It is the only way to select a block of text.

v			start/stop Visual mode per character. {not in Vi}

V			start/stop Visual mode linewise. {not in Vi}

CTRL-V			start/stop Visual mode blockwise. {not in Vi}

o			go to Other end of highlighted text: The current
			cursor position becomes the start of the highlighted
			text and the cursor is moved to the Other end of the
			highlighted text. {not in Vi} 

To apply an operator on a piece of text:
	1. mark the start of the text with "v", "V" or CTRL-V
		The character under the cursor will be used as the start.
	2. move to the end of the text
		The text from the start of the Visual mode up to and
		including the character under the cursor is highlighted.
	3. hit an operator
		The highlighted characters will be operated upon.

The 'highlight' option can be used to set the display mode to use for
highlighting in Visual mode.

The highlighted text includes the character under the cursor. On terminals
where it is possible to make the cursor invisible the cursor position is
also highlighted. On terminals where this is not possible the cursor is
displayed normally. If your cursor cannot be made invisible and you want Vim
to highlight the character under the cursor anyway, you could set the 't_cv'
and 't_ci' options to something harmless, for example:
        :set t_cv=^[^[ t_ci=^[^[

With "v" the text before the start position and after the end position will 
not be highlighted. However, All uppercase and non-alpha operators, except 
"~", will work on whole lines anyway. See the list of operators below.

With CTRL-V (blockwise Visual mode) the highlighted text will be a rectangle
between start position and the cursor. However, some operators work on whole
lines anyway (see the list below). The change and substitute operators will
delete the highlighted text and then start insertion at the top left
position. 

When the "$" command is used with blockwise Visual mode, the right end of the 
highlighted text will be determined by the longest highlighted line. This
stops when a motion command is used that does not move straight up or down.

If you use "v", "V", CTRL-V, ESC or any command that does a jump to another
window while in Visual mode, the highlighting stops and no text is affected.
If you hit CTRL-Z the highlighting stops and the editor is suspended or a new
shell is started.

For moving the end of the block many commands can be used, but you cannot 
use Ex commands, commands that make changes or abandon the file. Commands 
(starting with) ".pPiIaAO&", CTRL_^, "ZZ", CTRL-], CTRL-T, CTRL-R, CTRL-I 
and CTRL-O cause a beep and Visual mode continues. 

If the "v", "V" or CTRL-V is preceded with a count, the previously
highlighted area is used for a start. You can then move the end of the
highlighted area and give an operator. The type of the old area is used
(character, line or blockwise).
- Linewise Visual mode: The number of lines is multiplied with the count.
- Blockwise Visual mode: The number of lines and columns is multiplied with
  the count.
- Normal Visual mode within one line: The number of characters is multiplied
  with the count.
- Normal Visual mode with several lines: The number of lines is multiplied
  with the count, in the last line the same number of characters is used as
  in the last line in the previously highlighted area.
The start of the text is the Cursor position. If the "$" command was used as 
one of the last commands to extend the highlighted text, the area will be
extended to the rightmost column of the longest line.

The operators that can be used are:
	~	switch case
	d	delete
	c	change
	y	yank
	>	shift right (1)(*)
	<	shift left (1)(*)
	!	filter through external command (1)
	=	filter through 'equalprg' option command (1)
	Q	format lines to 'textwidth' length (1)

Additionally the following commands can be used:
	:	start ex command for highlighted lines (1)
	r	change
	s	change
	C	change (2)
	R	change (2)
	S	change (2)
	x	delete
	D	delete (2)
	X	delete (2)
	Y	yank (2)
	J	join (1)
	U	make uppercase
	u	make lowercase

(1): always whole lines
(2): whole lines when not using CTRL-V
(*): in a future a blockwise shift will move the block only, not whole
     lines.

If you want to give a register name using the """ command, do this just before 
typing the operator character: "v{move around}"xd".

If you want to give a count to the command, do this just before typing the
operator character: "v{move around}3>" (move lines 3 indents to the right).

When repeating a Visual mode operator, the operator will be applied to the
same amount of text as the last time:
- Linewise Visual mode: The same number of lines.
- Blockwise Visual mode: The same number of lines and columns.
- Normal Visual mode within one line: The same number of characters.
- Normal Visual mode with several lines: The same number of lines, in the
  last line the same number of characters as in the last line the last time.
The start of the text is the Cursor position. If the "$" command was used as 
one of the last commands to extend the highlighted text, the repeating will
be applied up to the rightmost column of the longest line.


	14. Various commands

CTRL-L			Clear and redraw the screen.

CTRL-Z			On Unix systems: Suspend Vim. On other systems: 
			start a new shell (like ":sh").

<HELP>		or
:h[elp]			Show the help file page by page. The help file name 
			can be set with the 'helpfile' option. Type an index
			character to go directly to a page. Type <SPACE> or
			CTRL-F (with MSDOS: page-down) to go one page
			forward. Type <b> or CTRL-B (with MSDOS: page-up) to
			go one page back. Type <a> to go back to the index.
			Type <CR> to get out of the help screen. {Vi: no
			help}

<DEL>			When entering a number: remove the last digit.

:[range]p[rint]		Print [range] lines (default current line).

:[range]p[rint] {count}
			Print {count} lines, starting with [range] (default
			current line, see 4.4.4).

:[range]l[ist] [count]
			Same as :print, but display unprintable characters
			with <^>.

:[range]nu[mber] [count]
			Same as :print, but precede each line with its line
			number.

:[range]# [count]	synonym for :number.

:=			Print the line number.

:sh[ell]		Escape to a shell (name from 'shell' option).

:![!]{cmd} [!][arg]	Execute {cmd} with the shell. The optional bangs are
			replaced with the previously given command. The 
			optional [arg] is appended. See also the 'shell' and 
			'shelltype' option.

:ve[rsion]		Print the version number of the editor. If the
			compiler used understands "__DATE__" the compilation
			date is mentioned. Otherwise a fixed release-date is
			shown.

K			Run a program to lookup the identifier under the 
			cursor. The name of the program is given with the 
			'keywordprg' (kp) option (default is "ref"). The
			identifier is formed of letters, numbers and the
			underscore. The identifier under or right of the
			cursor is used. The same can be done with the
			command
				":!{program} {identifier}". 
			There is an example of a program to use in the tools
			directory of Vim. It is called 'ref' and does a
			simple spelling check. {not in Vi}

[N]gs
:[N]sleep [N]		Do nothing for [N] seconds. Can be interrupted with
			CTRL-C (CTRL-break on MSDOS). "gs" stands for "goto
			sleep". {not in Vi}


	15. Repeating commands

15.1 Single repeats

.			Repeat last change with count replaced by [count].

Simple changes can be repeated with the "." command. Without a count, the 
count of the last change is used. If you enter a count, it will replace the 
last one. If the last change included a specification of a numbered 
register, the register number will be incremented. See the section on undo 
and redo for an example how to use this.


15.2 Multiple repeats

:[range]g[lobal]/{pattern}/[cmd]
			Execute the Ex command [cmd] (default ":p") on the
			lines within [range] where {pattern} matches.

:[range]g[lobal]!/{pattern}/[cmd]
			Execute the Ex command [cmd] (default ":p") on the
			lines within [range] where {pattern} does NOT match.

:[range]v[global]/{pattern}/[cmd]
			Same as :g!.

The global commands work by first scanning through the [range] lines and
marking each line where a match occurs. In a second scan the [cmd] is 
executed for each marked line with its line number prepended. If a line is 
changed or deleted its mark disappears. The default for [range] is the whole 
buffer (1,$). Use "CTRL-C" to interrupt the command. If an error message is
given for a line global aborts.

To repeat a non-Ex command, you will have to put the command in a file and 
use "source!". For example:
	:g/pat/so! scriptfile
Make sure that the scriptfile ends with a whole command, otherwise Vim will 
wait for you to type the rest of the command for each match. The screen will 
not have been updated, so you don't know what you are doing.
	
The undo/redo command will undo/redo the whole global command at once.


15.3 Complex repeats

q<0-9a-zA-Z">		Record typed characters into register <0-9a-zA-Z">
			(uppercase to append). The 'q' that stops recording
			is also stored in the register. The 'q' command is
			disabled while executing a register. (Implementation
			note: This was done because the 'q' command can be
			the result of mapping). {Vi: no recording}

q			Stops recording. {Vi: no recording}

@<0-9a-z">		Execute the contents of register <0-9a-z"> [count]
			times. {Vi: only named registers}

@:			Repeat last command line [count] times.

@@			Repeat the previous @<0-9a-z":> [count] times.

:[addr]@<0-9a-z">	Execute the contents of register <0-9a-z"> as
			an Ex command. First set cursor at line [addr]
			(default is current line). {Vi: only in some
			versions}

:[addr]@:		Repeat last command line [count] times. First set
			cursor at line [addr] (default is current line).
			{Vi: only in some versions}

:[addr]@@		Repeat the previous :@<0-9a-z">. First set cursor at
			line [addr] (default is current line). {Vi: only in
			some versions}

:so[urce] {file}	Read Ex commands from {file}.

:so[urce]! {file}	Read Vim commands from {file}. {not in Vi}

All commands and command sequences can be repeated by putting them in a named
register and then executing it. There are two ways to get the commands in the
register:
- Use the record command "q". You type the commands once, and while they are
  being executed they are stored in a register. Easy, because you can see 
  what you are doing. If you make a mistake, 'put' the register into the 
  file, edit the command sequence, and then delete it into the register 
  again. You can continue recording by appending to the register (use an 
  uppercase letter).
- Delete or yank the command sequence into the register.

Often used command sequences can be put under a function key with the ':map'
command.

An alternative is to put the commands in a file, and execute them with the
':source!' command. Useful for long command sequences. Can be combined with 
the ':map' command to put complicated commands under a function key.

The ':source' command reads Ex commands from a file line by line. You will 
have to type any needed keyboard input. The ':source!' command reads from a 
script file character by character, interpreting each character as if you 
typed it.

Example: When you give the ":!ls" command you are asked to "hit return to
continue". If you ':source' a file with the line "!ls" in it, you will have 
to type the return yourself. But if you ':source!' a file with the line 
":!ls" in it, the next characters from that file are read until a <CR> is 
found. You will not have to type <CR> yourself, unless ":!ls" was the last 
line in the file.

It is possible to put ':source[!]' commands in the script file, so you can 
make a top-down hierarchy of script files. The ':source' command can be 
nested as deep as the number of files that can be opened at one time (about 
15). The ':source!' command can be nested up to 15 levels deep.

In script files terminal-dependent key codes are represented by 
terminal-independent single character codes. In the MSDOS version the values
are 48 (0x30) higher. Any of these codes can be entered with CTRL-V followed
by the three digit decimal code.

	code	hex	meaning

	128	0x80	up-arrow
	129	0x81	down-arrow
	130	0x82	left-arrow
	131	0x83	right-arrow
	132	0x84	shift up-arrow
	133	0x85	shift down-arrow
	134	0x86	shift left-arrow
	135	0x87	shift right-arrow

	136	0x88	function key 1
	137	0x89	function key 2
	138	0x8a	function key 3
	139	0x8b	function key 4
	140	0x8c	function key 5
	141	0x8d	function key 6
	142	0x8e	function key 7
	143	0x8f	function key 8
	144	0x90	function key 9
	145	0x91	function key 10

	146	0x92	shifted function key 1
	147	0x93	shifted function key 2
	148	0x94	shifted function key 3
	149	0x95	shifted function key 4
	150	0x96	shifted function key 5
	151	0x97	shifted function key 6
	152	0x98	shifted function key 7
	153	0x99	shifted function key 8
	154	0x9a	shifted function key 9
	155	0x9b	shifted function key 10

	156	0x9c	help key
	157	0x9d	undo key
	158	0x9e	special-function key follows (MSDOS)
	159	0x9f	CTRL-@


	16. Undo and redo

<UNDO>		or
u			Undo [count] changes. {Vi: only one level}

:u[ndo]			Undo one change. {Vi: only one level}

CTRL-R			Redo [count] changes which were undone. {Vi: redraw 
			screen}

:red[o]			Redo one change which was undone. {Vi: no redo}

U			Undo all latest changes on one line. {Vi: while not
			moved off of it}

The last changes are remembered. You can go back in time with the "u" 
command. You can then go forward again with the 'CTRL-R' command. If you 
make a new change after the "u" command, the 'CTRL-R' will not be possible 
anymore. The number of changes that are remembered is set with the 
'undolevels' option. If it is zero, the old fashioned Vi undo is present: 
one level of undo and undo undoes itself. If it is negative no undo is
possible. Use this if you are running out of memory.

The "U" command is treated by undo/redo just like any other command. Thus a 
"u" command undos a "U" command and a 'CTRL-R' command redoes it again. When 
mixing "U", "u" and 'CTRL-R' you will notice that the "U" command will 
restore the situation of a line to before the previous "U" command. This may 
be confusing. Try it out to get used to it.

When all changes have been undone the buffer is not considered to be changed.
Vim can then be exit with ":q" instead of ":q!". {this is not in Vi}

The numbered registers can also be used for undoing deletes. Each time you 
delete text, it is put into register "1. The contents of register "1 are 
shifted to "2, etc. The contents of register "9 are lost. You can now get
back the most recent deleted text with the put command: '"1P'. (also, if the
deleted text was the result of the last delete or copy operation, 'P' or 'p'
also works as this puts the contents of the unnamed register). You can get
back the text of three deletes ago with '"3P'.

If you want to get back more than one part of deleted text, you can use a
special feature of the repeat command ".". It will increase the number of the
register used. So if you first do ""1P", the following "." will result in a
'"2P'. Repeating this will result in all numbered registers being inserted.

Example:	If you deleted text with 'dd....' it can be restored with
		'"1P....'.

If you don't know in which register the deleted text is, you can use the
:display command. An alternative is to try the first register with '"1P', and
if it is not what you want do 'u.'. This will remove the contents of the
first put, and repeat the put command for the second register. Repeat the
'u.' until you got what you want.


	17. Key mapping

:map {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in Command mode.

:map! {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in Insert and
			Command_line mode.

:noremap {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in Command mode. 
			Disallow remapping of {rhs}. {not in Vi}

:noremap! {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in insert and
			Command_line mode. Disallow remapping of {rhs}. {not 
			in Vi}

:unm[ap] {lhs}		Remove the mapping of {lhs} for Command mode.

:unm[ap]! {lhs}		Remove the mapping of {lhs} for Insert and
			Command_line mode.

:map			List all key mappings for Command mode.

:map!			List all key mappings for Insert and Command_line
			mode.

:map {lhs}		List the key mappings for the key sequences starting
			with {lhs} in Command mode. {not in Vi}

:map! {lhs}		List the key mappings for the key sequences starting
			with {lhs} in insert and Command_line mode. {not in Vi}

:cm[ap]			Same as :map, but for Command_line mode only. {not
			in Vi}

:cu[nmap]		Same as :unmap, but for Command_line mode only.
			{not in Vi}

:cno[remap]		Same as :noremap, but for Command_line mode only.
			{not in Vi}

:im[ap]			Same as :map, but for Insert mode only. {not in Vi}

:iu[nmap]		Same as :unmap, but for Insert mode only. {not in
			Vi}

:ino[remap]		Same as :noremap, but for Insert mode only. {not in
			Vi}

These commands are used to map a key or key sequence to a string of 
characters. You can use this to put command sequences under function keys, 
translate one key into another, etc. See the "Options" chapter below for how 
to save and restore the current mapping.

There are three sets of mappings
- For Insert mode. These are also used in Replace mode.
- For Command_line mode: When entering a ":" or "/" command.
- For Command mode: When typing commands.

The original vi did not have separate mappings for Insert mode and
Command_line mode. Therefore the ":map!" command enters and displays
mappings for both. In Vim you can use the ":cmap" and ":imap" commands to
enter mappings for each mode separately. When listing mappings with ":map!",
":cmap" or ":imap" the character in column 1 is <!> for mappings in both
Insert and Command_line mode, <i> for Insert mode only and <c> for
Command_line mode only.

Everything from the first non-blank after {lhs} up to the end of the line
(or <|>) is considered to be part of {rhs}. This allows the {rhs} to end
with a space.

To include a space in {lhs} precede it with a CTRL-V (type two CTRL-Vs for 
each space). If you want a {rhs} that starts with a space, precede {rhs} 
with a single CTRL-V (You have to type CTRL-V two times). You can create an 
empty {rhs} by typing nothing after the two CTRL-Vs.

It is not possible to put a comment after this command, because the <"> 
character is considered to be part of the {rhs}. To put a <|> in {rhs} 
escape it with a backslash or a CTRL-V (to get one CTRL-V you have to type 
it twice).

To avoid mapping of the characters you type in insert or Command_line mode, 
type a CTRL-V first. The mapping in Insert mode is disabled if the 'paste'
option is set.

Note that the second character (argument) of the commands @zZtTfF[]rm'`"v is
not mapped. This was done to be able to use all the named registers and
marks, even when the command with the same name has been mapped.

Some examples (given as you type them; e.g. the "^V" is CTRL-V which you 
type, but will not show up on the screen):

	:map g /foo^V^Mcwbar^V^[	(replace next "foo" by "bar")
	:map! qq quadrillion questions

Vim will compare what you type with the start of a mapped sequence. If there
is an incomplete match, it will get more characters until there either is a
complete match or until there is no match at all. Example: If you map! "qq",
the first <q> will not appear on the screen until you type another
character. This is because Vim cannot know if the next character will be a
<q> or not. If you set the 'timeout' option (which is the default) Vim will
only wait for one second (or as long as specified with the 'timeoutlen'
option). After that it assumes that the <q> is to be interpreted as such. If
type slowly, or your system is slow, reset the 'timeout' option. Then you
might want to set the 'ttimeout' option. See the "Options" chapter.

If you want to exchange the meaning of two keys you should use the :noremap 
command. For example:
	:noremap k j
	:noremap j k
This will exchange the cursor up and down commands. With the normal :map 
command, when the 'remap' option is set, mapping takes place until the text 
is found not to be a part of a {lhs}. For example, if you use:
	:map x y
	:map y x
Vim will replace x by y, and then y by x, etc. When this has happened 1000 
times, Vim will give an error message.

See the file "index" for keys that are not used and thus can be mapped 
without losing any builtin function.

If you include an undo command inside a mapped sequence, this will bring the 
text back in the state before executing the macro. This is compatible with 
the original vi, as long as there is only one undo command in the mapped 
sequence (having two undo commands in a mapped sequence did not make sense 
in the original vi, you would get back the text before the first undo).

There are two ways to map a function key:
1. The vi-compatible method: Map the key code. Often this is a sequence that
   starts with <ESC>. To enter a mapping like this you type ":map " and then
   you have to type CTRL-V before hitting the function key.
2. The second method is to use the internal code for the function key. To
   enter such a mapping just hit the function key, without CTRL-V, or use
   the form "#1", "#2", .. "#9", "#0". Only the first ten function keys can
   be used this way ("#0" refers to function key 10, defined with option
   't_f10', which may be function key zero on some keyboards).
The advantage of the second method is that the mapping will mostly work on
different terminals without modification (the function key will be
translated into the same internal code, no matter what terminal you are
using. The termcap must be correct for this to work, and you must use the
same mappings).

DETAIL: Vim first checks if a sequence from the keyboard is mapped. If it
isn't the terminal key codes are tried (see section 20.2). If a terminal
code is found it is replaced by the internal code. Then the check for a
mapping is done again (so you can map an internal code to something else).
What is written into the script file depends on what is recognized. If the
terminal key code was recognized as a mapping the key code itself is written
to the script file. If it was recognized as a terminal code the internal
code is written to the script file.


	18. Recovery after a crash.

You have spent several hours typing in that text that has to be finished
next morning, and then disaster strikes: Your computer crashes.

			DON'T PANIC!


18.1 The swap file

Vim stores the things you changed in a swap file. Using the original file
you started from plus the swap file you can mostly recover your work. You
can see the name of the current swap file being used with the command:

	:sw[apname]

The name of the swap file is normally the same as the file you are editing, 
with the extension ".swp". On MSDOS machines and when the 'shortname' option 
is set, any <.> in the original file name is replaced by <_>. If this file
already exists (e.g. when you are recovering from a crash) a warning is
given and another extension is used, ".swo", ".swn", etc. An existing file
will never be overwritten. The swap file is deleted as soon as Vim stops
editing the file.

Technical: The replacement of <.> by <_> is done to avoid problems with 
	   MSDOS compatible filesystems (e.g. crossdos, multidos). If Vim is 
	   able to detect that the file is on an MSDOS-like filesystem, a 
	   flag is set that has the same effect as the 'shortname' option. 
	   This flag is reset when you start editing another file.

	   If the ".swp" filename already exists, the last character is 
	   decremented until there is no file with that name or ".swa" is 
	   reached. In the last case, no swap file is created.

By setting the 'directory' option you can place the swap file in
another place than where the edited file is. The advantage is that you will
not pollute the directories with ".swp" files and, when the 'directory' is
on another partition, reduce the risk of damaging the file system where the
file is (in a crash). The tradeoff is that you can get name collisions from
files with the same name but in different directories. You can also use a
recoverable ram disk, but there is no 100% guarantee that this works.
Putting swap files in a normal ram disk (like RAM: on the Amiga) makes no
sense, you will loose them in a crash. If you want to put swap files in
another place, put a command resembling the following one in your .vimrc:
	:set dir=dh2:tmp
This is also very handy when editing files on floppy.

The swap file is updated after typing 200 characters or when you have 
not typed anything for four seconds. This only happens if the buffer was 
changed, not when you only moved around. The reason why it is not kept up to 
date all the time is that this would slow down normal work too much. You can 
change the 200 character count with the 'updatecount' option. You can set 
the time with the 'updatetime' option. The time is given in milliseconds.

If the writing to the swap file is not wanted, it can be switched off by
setting the 'updatecount' option to 0. The same is done when starting Vim 
with the "-n" or "-v" option. Writing can be switched back on by setting the 
'updatecount' option to non-zero. But this will only affect files that will
be opened after this.

If you want to make sure that your changes are in the swap file use this
command:

:pres[erve]		Write all text for all buffers into swap file. {Vi:
			emergency exit}

A Vim swap file can be recognized by the first six characters: "b0VIM ".
After that comes the version number, e.g. "3.0".


18.2 Recovery

In most cases recovery is quite easy: Start Vim on the same file you were
editing when the crash happened, with the "-r" option added. Vim will read
the ".swp" file and may read bits and pieces of the original file.

Example:	vim -r reference.doc

If the swap file does not end in ".swp" but in something else, you can
recover by giving the swap file name. Vim will then find out the name of the
original file from the swap file.

Example:	Vim -r reference.doc.swp

This is also handy when the swap file is in another directory than expected.
If this still does not work, see what file names Vim reports and rename the
files accordingly. 

There is some intelligence about what to do if the swap file is corrupt in
some way. If Vim has doubt about what it found, it will give an error
message and insert lines with "???" in the text. If you see an error message
while recovering, search in the file for "???" to see what is wrong. You may
want to cut and paste to get the text you need.

Be sure that the recovery was successful before overwriting the original
file or deleting the swap file. It is good practice to write the recovered
file elsewhere and execute 'diff' to find out if the changes you want are in
the recovered file.

Once you are sure the recovery is ok delete the swap file. Otherwise, you
will continue to get warning messages that the ".swp" file already exists.

{Vi: recovers in another way and sends mail if there is something to recover}


	19. Options

Vi has a number of internal variables and switches which can be set to 
achieve special effects. These options come in three forms, those that are 
switches, which toggle from off to on and back, those that require a numeric 
value, and those that require an alphanumeric string value.


19.1 Setting options

:se[t]			Show all modified options. {Vi: non-default options}

:se[t] all		Show all but terminal options.

:se[t] termcap		Show all terminal options.

:se[t] {option}		Set toggle option on, show value of string or number
			option.

:se[t] no{option}	Set toggle option off.

:se[t] inv{option}	Invert toggle option. {not in Vi}

:se[t] {option}={value} Set string or number option to {value}.

:se[t] {option}?	Show value of {option}.

The {option} arguments to ":set" may be repeated. For example:
	":set ai nosi sw=3 ts=3".
If you make an error in one of the arguments an error message will be given
and the text up to the next space will be skipped. Thus following arguments
will be processed.

The listing from ":set" looks different from vi. Long string options are put
at the end of the list. The number of options is quite large. The output of
"set all" probably does not fit on the screen, causing Vim to give the
"--more--" message. See the 'more' option.

An environment variable in most string options will be expanded. This
happens only when the string starts with a <$>. If the environment variable
exists the <$> and the following environment variable name is replaced by
its value. If it does not exist the <$> and the name are not modified. Any
non-id character (not a letter, digit or <_>) may follow the environment
variable name. That character and what follows is appended to the value of
the environment variable. Example:
	:set term=$TERM.new

Using "~/" is like using "$HOME".

Besides changing options with the ":set" command, there are four 
alternatives to set options automatically for one or more files. The first 
and second ones are used for all files. The third is used to set options for 
the files in one directory. The last is used to set options for a single 
file. The first three are done when you start Vim, in the given order. The 
last is done whenever you start editing a new file.

1. The environment variable VIMINIT is read for an Ex command. You can set
   VIMINIT to something like "set noai sw=3" to set options.
2. Only if there is no VIMINIT environment variable, the file 
   "s:.vimrc" is read for Ex commands. You can include set commands in this 
   file. (see below for how to automatically create a file with set commands).
3. If VIMINIT is not found and "s:.vimrc" does not exist, EXINIT is used, 
   in the same way as VIMINIT.
4. If VIMINIT is not found, "s:.vimrc" does not exist and EXINIT is not found, 
   the file "s:.exrc" is read for Ex commands.
5. If the 'exrc' option is set, the file ".vimrc" in the current directory is 
   read for Ex commands. You can include set commands in this file. If this 
   file is not found the file ".exrc" is tried.
6. If you start editing a new file, and the 'modeline' option is set, a
   number of lines at the beginning and end of the file are checked for the
   string "vi:", "vim:" or "ex:". The text after it is considered to be the
   arguments for a ":set" command, separated with colons or spaces. For
   example:
   		"vi:noai:sw=3 ts=6"
   The number of lines that are checked can be set with the 'modelines'
   option. If 'modeline' is not set or 'modelines' is 0 no lines are
   checked.
   The string "vi:", "vim:" or "ex:" must be preceded with a blank or begin 
   at the start of a line. This minimizes the chance that a normal word like 
   "lex:" is caught.
   Note that all of the rest of the line is used, thus a line like:
   		"/* vi:ts=4: */"
   will give an error message for the trailing "*/".
   If an error is detected the rest of the line is skipped.
   One other form of modelines is recognized that has the "set" command
   after "vi:", "vim:" or "ex:" (this is compatible with some versions of
   vi). In this case the characters up to the first <:> are executed as an
   ex command. Anything following it is ignored. Thus a line like:
   		"/* vi:set ts=4: */"
   is OK. If you want to include a <:> in a set command precede it with a
   <\>.


19.2 Saving settings

:mkexrc [file]		Write current key mappings and changed options to 
			[file] (default ".exrc"), unless it already exists. 
			{not in Vi}

:mkexrc! [file]		Always write current key mappings and changed 
			options to [file] (default ".exrc"). {not in Vi}

:mkvimrc[!] [file]	Same as :mkexrc, but default is ".vimrc". {not in 
			Vi}

These commands will write ":map" and ":set" commands to a file, in such a 
way that when these commands are executed, the current key mappings and 
options will be set again. A common method is to use a default ".exrc" file 
by first reading one in with ":source s:.exrc.Cprogs", change the settings 
and then save them in the current directory with ":mkexrc!".


19.3 Options summary

In the list below all the options are mentioned with their full name and some
with an abbreviation between parens. Both forms may be used. In this
document when an option that can be toggled is "set" that means that ":set
option" is entered.  When an option is "reset", ":set nooption" is used.

autoindent (ai)		toggle	(default off)
	Copy indent from current line when starting a new line (typing <CR> 
	in Insert mode or when using the "o" or "O" command). If you do not 
	type anything on the new line except <BS> and then type <ESC> or 
	<CR>, the indent is deleted again. When autoindent is set, 
	formatting (with the "Q" command or when you reach 'textwidth' in 
	Insert mode) uses the indentation of the first line. The 'autoindent'
	option is reset when the 'paste' option is set.

autowrite (aw)		toggle	(default off)
	Write the contents of the file, if it has been modified, on each
	:next, :rewind, :previous, :stop, :suspend, :tag, :!, :make, CTRL-]
	and CTRL-^ command; and when a CTRL-O, CTRL-I, '<A-Z>, or `<A-Z>
	command takes one to another file.

backspace (bs)		number	(default 0)
	Influences the working of <BS>, <DEL>, CTRL-W and CTRL-U in Insert 
	mode. If set to 0 Vi compatible backspacing is used. When 1 allow 
	backspacing over newlines. When larger than 1 allow backspacing over 
	the start of insert. In the last case CTRL-W and CTRL-U stop once at 
	the start of insert. {not in Vi}

backup (bk)		toggle	(default on)
	Make a backup before overwriting a file. Leave it around after the 
	file has been successfully written. If you do not want to keep the 
	backup file, but you do want a backup while the file is being
	written, reset this option and set the 'writebackup' option. If you
	do not want a backup file at all reset both options (See the table
	in section 5.4 for another explanation.). {not in Vi}

backupdir (bdir)	string	(default "$HOME")
	Directory name for the backup file. Empty means in same directory as
	the edited file. If the directory name starts with <>>, only the
	specified directory will be used. If there is a directory name but
	it does not start with <>>, the current directory is tried first.
	The specified directory is used only if that fails. The name may end
	in an <:> or </>. Environment variables are expanded. {not in Vi}

binary (bin)		toggle	(default off)
	This option should be set before editing a binary file. You can also
	use the "-b" command line option. When this option is set the
	'textwidth' option will set to 0, the 'textmode' and 'textauto'
	options will be reset and 'modelines' will be set to 0. When writing
	a file the end-of-line for the last line is only written if there
	was one in the original file (normally Vim appends an end-of-line to
	the last line if there is none; this would make the file longer). See
	the 'endofline' option. {not in Vi}

bioskey (bk)		toggle	(default on)
	For MSDOS only: When set the bios is called to obtain a keyboard
	character. This works better to detect CTRL-C, but only works for
	the console. When using a terminal over a serial port reset this
	option. {not in Vi}

cmdheight (ch)		number	(default 1)
	Number of lines to use for the command line. If you are annoyed by
	"hit return to continue" or "--more--" caused by long messages, set
	this option to a larger value. {not in Vi}

columns			number	(default 80 or terminal width)
	Number of columns in the display. Normally this is set by the 
	terminal initialization and does not have to be set by hand. {not in 
	Vi}

compatible (cp)		toggle	(default off)
	At the moment this option is set, several other options will be set 
	or reset to make Vim vi-compatible. Switching this option off has no 
	effect. {not in Vi}

	option		new value	effect

	backspace	0		normal backspace
	backup		off		no backup file
	digraph		off		no digraphs
	esckeys		off		no <ESC>-keys in Insert mode
	expandtab	off		tabs not expanded to spaces
	history		0		no commandline history
	insertmode	off		do not start in Insert mode
	joinspaces	on		insert 2 spaces after period
	modelines	0		no modelines
	more		off		no pauses in listings
	revins		off		no reverse insert
	ruler		off		no ruler
	scrolljump	0		no jump scroll
	shiftround	off		indent not rounded to shiftwidth
	showcmd		off		command characters not shown
	showmode	off		current mode not shown
	smartindent	off		no smart indentation
	textauto	off		no automatic textmode detection
	textwidth	0		no automatic line wrap
	tildeop		off		tilde is not an operator
	ttimeout	off		no terminal timeout
	undolevels	0		no multilevel undo
	updatecount	0		no swap file
	writebackup	off		no backup file written
	yankendofline	off		do not Yank to end of line

digraph (dg)		toggle	(default off)
	Enable the entering of digraphs in Insert mode with {char1} <BS> 
	{char2}. Only works if Vim was compiled with digraphs enabled. {not 
	in Vi}

directory (dir)		string	(default for Amiga: "t:", for MSDOS:
				"c:\tmp", for unix: "/tmp")
	Directory name for the swap file. Empty means in same directory as the
	edited file. If the directory name starts with <>>, only the
	specified directory will be used. If there is a directory name but
	it does not start with <>>, the current directory is tried first.
	The specified directory is used only if that fails. The name may end
	in an <:> or </>. Environment variables are expanded. Careful with
	<\> characters, type two to get one in the option, ":set
	dir=c:\\tmp". {Vi: directory to put temp file in, defaults to
	"/tmp"}

edcompatible		toggle	(default off)
	Makes the 'g' and 'c' flags of the ":substitute" command to be
	toggled each time the flag is given. See 11.3. See also 'gdefault'
	option.

endofline (eol)		toggle	(default on)
	When writing a file and this option is off and the 'binary' option is
	set, no end of line (newline) character will be written for the last
	line in the file. This option is automatically set when starting to
	edit a new file, unless the 'binary' options is set and the file does
	not have an end of line (newline) for the last line in the file, in
	which case it is reset. Normally you don't have to set or reset this
	option. When 'binary' is not set the value is not used. When 'binary'
	is set it is used to remember the presence of a newline for the last
	line in the file, so that when you write the file the situation from
	the original file can be kept. But you can change it when you want to.
	{not in Vi}

equalalways (ea)	toggle	(default on)
	When set all the windows are automatically made the same size after
	splitting or closing a window. If you don't set this option, splitting
	a window will reduce the size of the current window and leave the
	other windows the same. When closing a window the extra lines are
	given the the window above it. {not in Vi}

equalprg (ep)		string	(default "indent")
	External program to use for "=" command. Environment variables are
	expanded. {not in Vi}

errorbells (eb)		toggle	(default off)
	Ring the bell for error messages. Does not work on the Amiga, you 
	always get a screen flash.

errorfile (ef)		string	(default "AztecC.Err" or "errors")
	Name of the error file for the QuickFix mode (see 5.5). Environment
	variables are expanded. {not in Vi}

errorformat (efm)	string	(default "%f>%l:%c:%t:%n:%m" or
						""%f",%*[^0-9]%l %m")
	Scanf-like description of the format for the lines in the error file
	(see 5.5). {not in Vi}

esckeys (ek)		toggle	(default on)
	Function keys that start with an <ESC> are recognized in Insert
	mode. When this option is off, the cursor and function keys cannot be
	used in Insert mode if they start with an <ESC>. The advantage of this
	is that the single <ESC> is recognized immediately, instead of after
	one second.

expandtab (et)		toggle	(default off)
	In Insert mode: Use the appropriate number of spaces to insert a 
	<TAB>. Spaces are used in indents with the '>' and '<' commands and
	when 'autoindent' is set. To insert a real tab when expandtab is
	set, use CTRL-V<TAB>. {not in Vi}

exrc			toggle (default off)
	Enables the reading of .vimrc and .exrc in the current directory. If
	you switch this option on you should also consider setting the
	'secure' option (see 3.4). {not in Vi}

formatprg (fp)		string (default "")
	The name of an external program that will be used to format the
	lines selected with the "Q" command. The program must take the input
	on stdin and produce the output on stdout. The unix program 'fmt' is
	such a program. If this option is an empty string, the internal
	format function will be used. Environment variables are expanded.
	{not in Vi}

gdefault (gd)		toggle	(default off)
	When set, the ":substitute" flag 'g' is default on. This means that
	all matches in a line are substituted instead of one. See 11.3. {not
	in Vi} 

graphic (gr)		toggle	(default off, MSDOS: on)
	When off characters between <~> and 0xa0 are displayed as "~?", 
	"~@", "~A", etc.. When on the characters are sent to the display 
	directly. This will allow for graphic characters to be shown on some 
	terminals (e.g. MSDOS console) and mess up the display on others 
	(e.g. Amiga).

helpfile (hf)		string	(default (Amiga) "vim:vim.hlp"
					 (unix) "/usr/local/lib/vim.hlp")
	Name of the help file. It may start with an environment variable. 
	For example: "$VIM/doc/vim.hlp". Environment variables are expanded.
	{not in Vi}

hidden (hid)		toggle	(default off)
	When off the current buffer is unloaded when it is abandoned. When
	on the current buffer becomes hidden when starting to edit another
	buffer. If the current buffer is also displayed in another window it
	does not become hidden. The commands that move through the buffer
	list make the current buffer hidden although the 'hidden' option is
	not set. See also 'windows.doc'. {not in Vi} 

highlight (hl)		string	(default "db,es,hs,rs,vi,si")
	This option can be used to set highlighting mode for various
	occasions. It is a comma separated list of character pairs. The first
	character in a pair gives the occasion, the second the mode to use for
	that occasion. The occasions are:
		v	visual mode
		d	directories in CTRL-D listing
		e	error messages
		s	status lines
		h	help file headers
		r	return to continue message and yes/no questions
	The display modes are:
		i	invert		(termcap entry "mr")
		b	bold		(termcap entry "md")
		s	standout	(termcap entry "so")
		n	no highlighting
	The default is to use bold for directories, standout for error
	messages, help file headers and return, invert for visual mode and
	status lines.
	Invert is used for occasions that are not included. {not in Vi}

history (hi)		number	(default 20)
	Number of command lines that are remembered. {not in Vi}

icon			toggle	(default off)
	When set the icon of the window will be set to the name of the file
	currently being edited. Only the last part of the name is used. Only
	works if the terminal supports setting window icons (currently only
	Unix xterm and iris-ansi). When Vim was compiled with USE_X11
	defined, the original icon will be restored if possible. {not in Vi}

ignorecase (ic)		toggle	(default off)
	Ignore case in search patterns. Also used when searching in the tags
	file.

insertmode (im)		toggle	(default off)
	Start the edit of a file in Insert mode. {not in Vi}

joinspaces (js)		toggle	(default on)
	Insert two spaces after a period with a join command. {not in Vi}

keywordprg (kp)		string	(default "ref")
	Program to use for the "K" command. Environment variables are
	expanded. {not in Vi}

laststatus (ls)		number	(default 1)
	The value of this option influences when the last window will have a
	status line:
		0: never
		1: only if there are at least two windows
		2: always
	The screen looks nicer with a status line if you have several
	windows, but it takes another screen line. {not in Vi}

lines			number	(default 24 or terminal height)
	Number of lines in the display. Normally you don't need to set this. 
	That is done automatically by the terminal initialization code.

list			toggle	(default off)
	List mode: Show tabs as CTRL-I, show end of line with $. Useful to 
	see the difference between tabs and spaces and for trailing blanks.

magic			toggle	(default on)
	Changes the special characters that can be used in search patterns. 
	See section "Pattern searches".

makeprg (mp)		string	(default "make")
	Program to use for the ":make" command. This option may contain
	<%> and <#> characters, which are expanded like when used in a
	command line. Environment variables are expanded. {not in Vi}

maxmem (mm)		number	(default 512)
	Maximum amount of memory (in Kbyte) to use for one buffer. When this
	limit is reached allocating extra memory for a buffer will cause
	other memory to be freed. See also 'maxmemtot'. {not in Vi}

maxmemtot (mmt)		number	(default 512)
	Maximum amount of memory (in Kbyte) to use for all buffers together.
	Added 'maxmemtot' option ('mmt'), maximal Kbyte to use for
	all buffers.

modeline (ml)		toggle	(default on)
modelines (mls)		number	(default 5)
	If 'modeline' is set 'modelines' gives the number of lines that is
	checked for set commands. If 'modeline' is not set or 'modelines' is
	0 no lines are checked. See 19.1. {not in Vi}

more			toggle	(default on)
	Listings pause when the whole screen is filled. Type <CR> for one
	more line. Type <SPACE> for the next page. Type 'q' to stop the
	listing. When this option is off there are no pauses, the listing
	continues until finished. When Vim was compiled with COMPATIBLE
	defined this option is default off. When 'compatible' is set this
	option is off. {not in Vi}

nobuf (nb)		toggle	(default off)
	When set characters are send to the terminal one by one. For MSDOS
	pcterm this does not work. For debugging purposes. {not in Vi}

number (nu)		toggle	(default off)
	Print the line number in front of each line.

paragraphs (para)	string	(default "IPLPPPQPP LIpplpipbp")
	Specifies the nroff macros that separate paragraphs. These are pairs 
	of two letters (see section 6.4).

paste			toggle	(default off)
	Put Vim in Paste mode. This is useful if you want to cut or copy
	some text from one window and paste it in Vim. This will avoid
	unexpected effects. When the 'paste' option is set mapping in Insert
	mode is disabled, abbreviations are disabled and some options are
	reset ('textwidth', 'autoindent', 'smartindent', 'revins', 'ruler'
	and 'showmatch'). When the 'paste' option is reset the mentioned
	options are restored to the value before the moment 'paste' was
	set. Resetting 'paste' before ever setting it does not have any
	effect. If you use this often, you could map a function key to the
	command ":set invpaste^V^M". {not in Vi}

patchmode (pm)		string	(default "")
	Only for Unix: When set the oldest version of a file is kept. This can
	be used to keep the original version of a file if you are changing
	files in a source distribution. Only the first time that a file is
	edited a copy of the original file will be kept. The name of the copy
	is the name of the original file with the string in the 'patchmode'
	option appended. This option should start with a dot. Use a string
	like ".org". Only works properly if the 'backup' or the 'writebackup'
	option is set. If both are not set, an empty file is created with the
	'patchmode' option appended to the name of the original file. This
	means that you can only see which files where changed. {not in Vi}

readonly (ro)		toggle	(default off)
	If set, writes fail unless you use an !. Protects you from
	accidentally overwriting a file. Also, sets 'updatecount' to zero so
	that no ".swp" swap file is created. Default on when vim is started
	in view mode ("vim -v") or when the executable is called "view". It
	is reset if you overwrite the current file (e.g. with ":w!").

remap			toggle	(default on)
	Allows for :map command to work recursively. If you do not want this 
	for a single entry, use the :noremap[!] command.

report			number	(default 2)
	Threshold for reporting number of lines changed.

revins			toggle	(default off)
	Inserting characters in Insert mode will work backwards. See "typing
	backwards". Can be toggled with the CTRL-B command in Insert mode.
	This option is reset when 'compatible' or 'paste' is set. {not in Vi}

ruler (ru)		toggle	(default off)
	Show the line and column number of the cursor position in the status
	line, separated by a comma. If there are characters in the line that
	take two positions on the screen, both the "real" column and the
	screen column are shown, separated with a dash. This option is reset
	when the 'paste' option is set. {not in Vi}

scroll			number	(default 'lines' / 2)
	Number of lines to scroll with CTRL-U and CTRL-D commands. Will be
	set to half the number of lines in the window when the window size
	changes. If you give a count to the CTRL-U or CTRL-D command it will
	be used as the new value for 'scroll'. Reset to 'lines' / 2 with
	":set scroll=0".

scrolljump		number	(default 1)
	Minimal number of lines to scroll when the cursor gets off the 
	screen (e.g. with "j"). Not used for scroll commands (e.g. CTRL-E, 
	CTRL-D). Useful if your terminal scrolls very slowly. {not in Vi}

sections (sect)		string	(default "SHNHH HUnhsh")
	Specifies the nroff macros that separate sections. These are pairs of
	two letters (See section 6.4).

secure			toggle	(default off)
	When on, shell and write commands are not allowed in ".vimrc" and 
	".exrc" in the current directory and map commands are displayed.
	Switch it off only if you know that you will not run into problems,
	or when the 'exrc' option is off. On unix this option is only used
	if the ".vimrc" or ".exrc" is not owned by you.

shell (sh)		string	(default $SHELL or "sh", MSDOS: "command")
	Name of the shell to use for ! and :! commands. See also the
	'shelltype' option. It is allowed to give an argument to the 
	command, e.g. "csh -f". If you type this in the command line you 
	will have to put a backslash in front of the space. Environment
	variables are expanded.

shellpipe (sp)		string	(default ">", "| tee", "|& tee" or "2>&1| tee")
	String to be used to put the output of the ":make" command in the
	error file. For the Amiga and MSDOS the default is ">". The output
	is directly saved in a file and not echoed to the screen. For Unix
	the default it "| tee". The stdout of the compiler is saved in a
	file and echoed to the screen. If the 'shell' option is "csh" during
	initializations, the default becomes "|& tee". If the 'shell' option
	is "sh", "ksh" or "bash" the default becomes "2>&1| tee". This means
	that stderr is also included. Setting the 'shell' option does not
	automatically change the 'shellpipe' option.

shelltype (st)		number	(default 0)
	On the Amiga this option influences the way how the commands work 
	which use a shell.
	0 and 1: always use the shell
	2 and 3: use the shell only to filter lines
	4 and 5: use shell only for ':sh' command
	When not using the shell, the command is executed directly.

	0 and 2: use 'shell -c cmd' to start external commands
	1 and 3: use 'shell cmd' to start external commands

shiftround (sr)		toggle	(default off)
	Round indent to multiple of shiftwidth. Applies to > and < commands 
	and to CTRL-T and CTRL-D in Insert mode. {not in Vi}

shiftwidth (sw)		number	(default 8)
	Number of spaces to use for (auto)indent.

shortname (sn)		toggle	(default off)
	Filenames can be 8 characters plus one extension of 3 characters. 
	Multiple dots in file names are not allowed. When this option is on, 
	dots in filenames are replaced by underscores when adding an 
	extension (".bak" or ".swp"). This option is not available for 
	MSDOS, because then it would always be on. This option is useful 
	when editing files on an MSDOS compatible filesystem, e.g. messydos 
	or crossdos. {not in Vi}

showcmd (sc)		toggle	(default on, off for unix)
	show command in status line. Set this option off if your terminal 
	is slow. {not in Vi}

showmatch (sm)		toggle	(default off)
	When a bracket is inserted, briefly jump to the matching one. This
	option is reset when the 'paste' option is set.

showmode (smd)		toggle	(default on)
	If in Insert or Replace mode, put a message on the last line.

sidescroll (ss)		number	(default 0)
	The minimal number of columns to scroll horizontally. Used only when
	the 'wrap' option is on and the cursor is moved off of the screen.
	When set to zero the cursor will be put in the middle of the screen.
	When using a slow terminal set it to a large number or 0. When using
	a fast terminal use a small number or 1. {not in Vi}

smartindent (si)	toggle	(default off)
	Do smart autoindenting for C programs in Insert mode and with the
	"o" and "O" commands. An indent is automatically inserted:
	- After a line ending in <{>.
	- After a line starting with "if", "for", "while", "else" or "do".
	  If you type a <{> as the first character in the new line, the
	  indent is deleted. 
	- Before a line starting with <}> (only with the "O" command).
	When typing <}> as the first character in a new line, that line is
	given the same indent as the matching <{>.
	When typing <#> as the first character in a new line, the indent for
	that line is removed, the <#> is put in the first column. The indent
	is restored for the next line.
	When using the ">>" command, lines starting with <#> are not shifted
	right.
	'smartindent' is reset when the 'paste' option is set. {not in Vi}

smarttab (sta)		toggle	(default off)
	When set a TAB in front of a line inserts 'shiftwidth' positions,
	'tabstop' in other places. When not set a TAB always inserts 'tabstop'
	positions, 'shiftwidth' is only used for ">>" and the like. {not in
	Vi}

splitbelow (sb)		toggle	(default off)
	When set new window from split is below the current one. {not in Vi}

suffixes (su)		string	(default ".bak.o.h.info.swp")
	Files with these suffixes are ignored when multiple files match a
	wildcard. {not in Vi}

tabstop (ts)		number	(default 8)
	Number of spaces that a <TAB> in the file counts for.

taglength (tl)		number	(default 0)
	If non-zero, tags are significant up to this number of characters.

tagrelative (tr)	toggle	(default on)
	If set and using a tag file in another directory, file names in that
	tag file are relative to the directory where the tag file is. If Vim
	was compiled with COMPATIBLE defined, or when the 'compatible' option
	is set, this option is reset. {not in Vi}

tags			string	(default "tags")
	Filenames for the tag command, separated by spaces. Environment
	variables are expanded for the first name. {Vi: default is "tags
	/usr/lib/tags"}

term			string	(default $TERM or "amiga" on Amiga, "pcterm"
					on MSDOS)
	Name of the terminal. Used for choosing the terminal control 
	characters. Environment variables are expanded.

terse			toggle	(default off)
	Shorten some of the messages. {Vi shortens a lot more messages}

textauto (ta)		toggle	(default on)
	When a new file is edited the first line is checked for the line
	separator. If it is a single <LF> 'textmode' is reset. If it is a
	<CR><LF> pair 'textmode' is set. {not in Vi}

textmode (tx)		toggle	(MSDOS: default on, others: default off)
	When off, <LF> separates lines. When on, <CR><LF> separates lines
	and CTRL-Z at end of file is ignored. Only used when reading and
	writing files. Set automatically when reading a file and 'textauto'
	is on. {not in Vi}

textwidth		number	(default 0)
	Maximum width of text that is being inserted. A longer line will be
	broken after white space to get this width. A zero value disables
	this. 'textwidth' is set to 0 when the 'paste' option is set. When
	'textwidth' is zero, 'wrapmargin' may be used. {not in Vi} 

tildeop (to)		toggle	(default off)
	The tilde command <~> behaves like an operator. {not in Vi}

timeout			toggle (default on)
ttimeout		toggle (default off)
	These two options together determine the behaviour when part of a 
	mapped key sequence or keyboard code has been received:

	timeout		ttimeout	action
	off		off		no time out
	on		on or off	time out on :mappings and key codes
	off		on		time out on key codes

	If there is no time out, Vim will wait until either the complete 
	mapping or key sequence has been received, or it is clear that there 
	is no mapping or key sequence for the received characters. For 
	example: if you have mapped "vl" and Vim has received <v>, the next 
	character is needed to see if the <v> is followed by an <l>. With a 
	time out Vim will wait for about 1 second for the next character to 
	arrive. After that the already received characters are interpreted
	as single characters. The time can be set with the 'timeoutlen'
	option.
	On slow terminals or very busy systems time out may cause 
	malfunctioning cursor keys. If both options are off, Vim waits 
	forever after an entered <ESC> if there are key codes that start 
	with <ESC>. You will have to type <ESC> twice. If you do not have 
	problems with key codes, but would like to have :mapped key 
	sequences not time out in 1 second, set the ttimeout option and 
	reset the timeout option. {the ttimeout option is not in Vi}

timeoutlen (tm)		number	(default 1000)
	The time in milliseconds that is waited for a key code or mapped key
	sequence to complete. {only in some versions of Vi}

title			toggle	(default on)
	When set the title of the window will be set to "VIM - filename",
	where filename is the name of the file currently being edited. Only
	works if the terminal supports setting window titles (currently Amiga
	console, Unix xterm and iris-ansi). When Vim was compiled with NOTITLE
	defined the default is off. When Vim was compiled with USE_X11
	defined, the original title will be restored if possible. {not in Vi}

ttyfast	(tf)		toggle (default off)
	Indicates a fast terminal connection. More characters will be send
	to the screen for redrawing, instead of using insert/delete line
	commands. Improves smoothness of redrawing when there are multiple
	windows and the terminal does not support a scrolling region. {not
	in Vi} 

undolevels (ul)		number	(default 100)
	Maximum number of changes that can be undone. Set to 0 for Vi 
	compatibility: one level of undo and 'u' undoes itself. Set to a
	negative number for no undo at all (saves memory). {not in Vi}

updatecount (uc)	number	(default 200)
	After this many characters typed the swap file will be written to
	disk. When zero the swap script will not be written at all (see
	chapter on recovery). {not in Vi}

updatetime (ut)		number	(default 4000)
	If this many milliseconds nothing is typed the swap file will be
	written to disk (see chapter on recovery). {not in Vi}

visualbell (vb)		toggle	(default off)
	Use (sort of) visual bell for AUX device. {not in Vi}

warn			toggle	(default on)
	Give a warning message when a shell command is used while the buffer
	has been changed.

weirdinvert (wi)	toggle	(default off)
	Set this option for terminals that have a weird inversion method.
	Makes the start/end invert code outputted before every character.
	Slows down terminal I/O a lot, but it makes Visual mode work.
	{not in Vi}

whichwrap (ww)		number	(default 3)
	Allow specified keys that move the cursor left/right to wrap to the
	previous/next line when the cursor is on the first/last character in
	the line. Add numbers to allow this for these keys:
		 1 for backspace	 in command mode
		 2 for space		 in command mode
		 4 for 'h' and 'l'	 in command mode
		 8 for cursor left/right in command mode
		16 for cursor left/right in insert mode
	For example: ":set ww=24" allows wrap only when cursor keys are used.
	When compiled with COMPATIBLE defined or when 'compatible' option set,
	'whichwrap' is set to 0.
	{not in Vi}

wildchar (wc)		number	(default <TAB> or CTRL-E)
	Character you have to type to start wildcard expansion in the 
	command line. CTRL-E is used when Vim was compiled with COMPATIBLE 
	or when the 'compatible' option is set. The character is not
	recognized when used inside a macro. {not in Vi}

winheight (wh)		number	(default 0)
	Minimal number of lines for the current window. If the current
	window is smaller, its size is increased, at the cost of the height
	of other windows. Set it to 999 to make the current window always
	fill the screen. Set it to a small number for normal editing. The
	height is not adjusted after one of the commands to change the
	height of the current window. {not in Vi} 

wrap			toggle	(default on)
	When on, long lines will wrap and continue on the next line. When
	off long lines will not wrap and only part of them will be shown.
	When the cursor is moved to a part that is not shown, the screen
	will scroll horizontally (also see 'sidescroll' option. {not in Vi}

wrapmargin (wm)		number	(default 0)
	Number of characters from the right window border where wrapping
	starts. When 'textwidth' is set, this option is not used. {Vi: works
	differently and less useful}

wrapscan (ws)		toggle	(default on)
	Searches wrap around the end of the file.

writeany (wa)		toggle	(default off)
	Allows writing to any file with no need for "!" override.

writebackup (wb)	toggle	(default on)
	Make a backup before overwriting a file. The backup is removed after 
	the file was successfully written, unless the 'backup' option is also 
	on. {not in Vi}

yankendofline (ye)	toggle	(default off)
	The Y command yanks from the cursor until the end of the line instead
	of whole lines. {not in Vi}


	20. Terminal information

Vim uses information about the terminal you are using to fill the screen and 
recognize what keys you hit. If this information is not correct the screen 
may be messed up or keys may not be recognized. The actions which have to be 
performed on the screen are accomplished by outputting a string of
characters. Special keys produce a string of characters. These strings are 
stored in the terminal options, see section 20.2.


20.1 startup

When Vim is started a default terminal type is assumed. For the Amiga this 
is a standard CLI window, for MSDOS the pc terminal, for Unix an ansi 
terminal. A few other terminal types are always available. Use the command 
"set term=xxx" to find out which ones are builtin.

You can give the terminal name with the '-T' command line option. If it is 
not given Vim will try to get the name from the TERM environment variable.

On Unix the termcap file is used. On Amiga and MSDOS this is only available 
if Vim was compiled with TERMCAP defined. If the termcap code is included 
Vim will try to get the strings for the terminal you are using from the 
termcap file.

For normal editing the terminal will be put into "raw" mode. The strings 
defined with 't_ts' and 't_ks' will be sent to the terminal. Normally this 
puts the terminal in a state where the termcap codes are valid and activates 
the cursor and function keys. When Vim exits the terminal will be put back 
into the mode it was before Vim started. The strings defined with 't_te' and 
't_ke' will be sent to the terminal. On the Amiga with commands that execute
an external command (e.g. "!!") the terminal will be put into normal mode
for a moment. This means that you can stop the output to the screen by
hitting a printing key. Output resumes when you hit <BS>.

Some termcap entries are wrong in the sense that after sending 't_ks' the 
cursor keys send codes different from the codes defined in the termcap. To 
avoid this you can set 't_ks' (and 't_ke') to empty strings. This must be
done during initialization (see 3.4), otherwise its too late.

Some termcap entries assume that the highest bit is always reset. For 
example: The cursor-up entry for the amiga could be ":ku=\EA:". But the 
Amiga really sends "\233A". This works fine if the highest bit is reset, 
e.g. when using an Amiga over a serial line. If the cursor keys don't work, 
try the entry ":ku=\233A:".

Some termcap entries have the entry ":ku=\E[A:". But the Amiga really sends 
"\233A". On output "\E[" and "\233" are often equivalent, on input they 
aren't. You will have to change the termcap entry, or change the key code 
with the :set command to fix this.

Many cursor key codes start with an <ESC>. Vim must find out if this a 
single hit of the <ESC> key or the start of a cursor key sequence. It waits 
for a next character to arrive. If it does not arrive within one second a 
single <ESC> is assumed. On very slow systems this may fail, causing cursor 
keys not to work sometimes. If you discover this problem reset the 'timeout' 
option. Vim will wait for the next character to arrive after an <ESC>. If 
you want to enter a single <ESC> you must type it twice. Resetting the
'esckeys' option avoids this problems in Insert mode, but you lose the
possibility to use cursor and function keys in Insert mode.

On the Amiga the recognition of window resizing is activated only when the 
terminal name is "amiga" or "builtin_amiga".

Some terminals have confusing codes for the cursor keys. The televideo 925
is such a terminal. It sends a CTRL-H for cursor-left. This would make it
impossible to distinguish a backspace and cursor-left. To avoid this problem
CTRL-H is never recognized as cursor-left.


20.2 terminal options

The terminal options can be set just like normal options. But they are not
shown with the ":set all" command. Instead use ":set termcap".

It is always possible to change individual strings by setting the 
appropriate option. For example:

	:set t_el=^V^[[K	(CTRL-V, ESC, [, K)

{Vi: no terminal options. You have to exit vi, edit the termcap entry and
try again}

The options are listed below along with the associated termcap code. Two of
them are required: Cursor positioning and clear screen. The others are used
to minimize the screen updating overhead and to recognize special keys.


	option	termcap		meaning

OUTPUT CODES
	t_name	(name)	name of current terminal entry
	t_el	ce	clear to end of line
	t_il	al	add new blank line
	t_cil	AL	add number of blank lines
	t_dl	dl	delete line
	t_cdl	DL	delete number of lines
	t_cs	cs	define scrolling region
	t_ed	cl	clear screen (required!)
	t_ci	vi	cursor invisible
	t_cv	ve	cursor visible
	t_cvv	cvv	cursor very visible
	t_tp	me	normal mode (undoes t_ti and t_tb)
	t_ti	mr	reverse (invert) mode
	t_tb	md	bold mode
	t_se	se	standout end
	t_so	so	standout mode
	t_ms	ms	if set, cursor can be moved in standout/inverse mode
	t_cm	cm	cursor motion (required!)
	t_sr	sr	scroll reverse (backward)
	t_cri	RI	cursor number of chars right
	t_vb	vb	visual bell
	t_ks	ks	put terminal in "keypad transmit" mode
	t_ke	ke	out of "keypad transmit" mode
	t_ts	ti	put terminal in "termcap" mode
	t_te	te	out of "termcap" mode

KEY CODES
	t_ku	ku	arrow up
	t_kd	kd	arrow down
	t_kr	kr	arrow right
	t_kl	kl	arrow left
	t_sku	(none)	shift arrow up
	t_skd	(none)	shift arrow down
	t_skr	%i	shift arrow right
	t_skl	#4	shift arrow left
	t_f1	k1	function key 1
	t_f2	k2	function key 2
	t_f3	k3	function key 3
	t_f4	k4	function key 4
	t_f5	k5	function key 5
	t_f6	k6	function key 6
	t_f7	k7	function key 7
	t_f8	k8	function key 8
	t_f9	k9	function key 9
	t_f10	k;	function key 10
	t_sf1	F1	function key 11 or shifted function key 1
	t_sf2	F2	function key 12 or shifted function key 2
	t_sf3	F3	function key 13 or shifted function key 3
	t_sf4	F4	function key 14 or shifted function key 4
	t_sf5	F5	function key 15 or shifted function key 5
	t_sf6	F6	function key 16 or shifted function key 6
	t_sf7	F7	function key 17 or shifted function key 7
	t_sf8	F8	function key 18 or shifted function key 8
	t_sf9	F9	function key 19 or shifted function key 9
	t_sf10	FA	function key 20 or shifted function key 10
	t_help	%1	help key
	t_undo	&8	undo key

Note about t_so and t_ti: When the termcap entry "so" is not present the
entry for "mr" is used. And visa versa. The same is done for "se" and "me".
If your terminal supports both inversion and standout mode, you can see two
different modes. If you terminal supports only one of the modes, both will
look the same.

If inversion or other highlighting does not work correctly, try setting the
'weirdinvert' option. This makes the start-highlight or end-highlight termcap
code to be outputted before every character. This slows down terminal I/O a
lot, but it makes inversion work on some terminals.

Some termcaps do not include an entry for 'cs' (scroll region), although the
terminal does support it. For example: xterm on a sun. You can use the
builtin_xterm or define t_cs yourself. For example:

	:set t_cs=^V^[[%i%d;%dr

Where ^V is CTRL-V and ^[ is <ESC>.

Unfortunately it is not possible to deduct from the termcap how cursor
positioning should be done when using a scrolling region: Relative to the
beginning of the screen or relative to the beginning of the scrolling region.
Most terminals use the first method. A know exception is the MSDOS console
(pcterm). The 't_csc' option should be set to any string when cursor
positioning is relative to the start of the scrolling region. It should be set
to an empty string otherwise. It is default "yes" when 'term' is "pcterm".

Note for xterm users: The shifted cursor keys normally don't work. You can
	make them work with the xmodmap command and some mappings in Vim.

	Give these commands in the xterm:
		xmodmap -e "keysym Up = Up F16"
		xmodmap -e "keysym Down = Down F17"
		xmodmap -e "keysym Left = Left F18"
		xmodmap -e "keycode Right = Right F19"

	And use these mappings in Vim:
		:map CTRL-V 151 CTRL-V 132
		:map! CTRL-V 151 CTRL-V 132
		:map CTRL-V 152 CTRL-V 133
		:map! CTRL-V 152 CTRL-V 133
		:map CTRL-V 153 CTRL-V 134
		:map! CTRL-V 153 CTRL-V 134
		:map CTRL-V 154 CTRL-V 135
		:map! CTRL-V 154 CTRL-V 135

Where 151-154 are the internal vim decimal codes for function keys F16 to
F19 and 132-135 are the codes for the shifted arrow keys.


20.3 Window size

[This is about the size of the whole window Vim is using, not a window that is
created with the :split command]

If you are running Vim on an Amiga and the terminal name is "amiga" or 
"builtin_amiga", the amiga-specific window resizing will be enabled. On Unix 
systems three methods are tried to get the window size:

- an ioctl call (TIOCGSIZE or TIOCGWINSZ, depends on your system)
- the environment variables "LINES" and "COLUMNS"
- from the termcap entries "li" and "co"

If everything fails a default size of 24 lines and 80 columns is assumed. If 
a window-resize signal is received the size will be set again. If the window 
size is wrong you can use the 'lines' and 'columns' options to set the 
correct values.

One command can be used to set the screen size:

:mode [mode]

Without argument this only detects the screen size. With MSDOS it is possible
to switch screen mode. [mode] can be one of these values:
	"bw40"		40 columns black&white
	"c40"		40 columns color
	"bw80"		80 columns black&white
	"c80"		80 columns black&white (most people use this)
	"mono"		80 columns monochrome
	"c4350"		43 or 50 lines EGA/VGA mode
	number		mode number to use, depends on your video card


20.4 slow and fast terminals

If you have a fast terminal you may like to set the 'ruler' option. The 
cursor position is shown in the status line. If you are using horizontal
scrolling ('wrap' option off) consider setting 'sidescroll' to a small
number. 

If you have a slow terminal you may want to reset the 'showcmd' option. 
The command characters will not be shown in the status line. If the terminal 
scrolls very slowly, set the 'scrolljump' to 5 or so. If the cursor is moved
off the screen (e.g. with "j") Vim will scroll 5 lines at a time. Another
possibility is to reduce the number of lines that Vim uses with the command
"z<height><CR>".

If the characters from the terminal are arriving with more than 1 second 
between them you might want to set the 'timeout' and/or 'ttimeout' option. 
See the "Options" chapter.

If your terminal does not support a scrolling region, but it does support
insert/delete line commands, scrolling with multiple windows may make the
lines jump up and down. If you don't want this set the 'ttyfast' option.
This will redraw the window instead of scroll it.

If you are testing termcap options, but you cannot see what is happening,
you might want to set the 'nobuf' option ('nb'). When set one character is
send to the terminal at a time (does not work for MSDOS). This makes the
screen updating a lot slower, making it possible to see what is happening.


	21. Differences from Vi and Ex

Throughout this document differences between Vim and Vi/Ex are given in
curly braces. This chapter only lists what has not been mentioned in
previous chapters. Also see "difference.doc" for an overview.


21.1 Missing commands

A large number of the "Ex" commands (the commands that start with a colon) 
are included. However, there is no Ex mode. 

These commands are in Vi, but not in Vim.

Q			{Vi: go to Ex mode}

:a[ppend]		{Vi: append text}
:c[hange]		{Vi: replace lines}
:i[nsert]		{Vi: insert text}
:o[pen]			{Vi: start editing in open mode}
:rec[over]		{Vi: recover a file after a crash or :preserve}
:z			{Vi: print some lines}


21.2 Missing options

These options are in the unix Vi, but not in Vim. If you try to set one of
them you won't get an error message, but the value is not used and cannot be
printed.

autoprint (ap)		toggle	(default on)
beautify (bf)		toggle	(default off)
hardtabs (ht)		number	(default 8)
	number of spaces that a <TAB> moves on the display
lisp			toggle	(default off)
mesg			toggle	(default on)
open			toggle	(default on)
optimize (op)		toggle	(default on)
prompt			toggle	(default on)
redraw			toggle	(default off)
slowopen (slow)		toggle	(default off)
sourceany		toggle	(default not documented)
ttytype			string
window			number	(default 24)
w300			number	(default 24)
w1200			number	(default 24)
w9600			number	(default 24)



CONTENTS

[Note: The commands for multiple windows and buffers are explained in
windows.doc]

 1. Introduction
 2. Notation
 3. Starting Vim
	3.1 Command line
	3.2 Workbench (Amiga only)
	3.3 Vim window (Amiga only)
	3.4 Initialization
	3.5 Suspending
 4. Modes
	4.1 Introduction
	4.2 Switching from mode to mode
	4.3 Insert and Replace mode
		4.3.1 special keys
		4.3.2 special special keys
		4.3.3 'textwidth' option
		4.3.4 'expandtab' option
		4.3.5 typing backwards
		4.3.6 Replace mode
		4.3.7 Keyword completion
	4.4 Command_line mode
		4.4.1 Command line editing
		4.4.2 Command line completion
		4.4.3 Ex command lines
		4.4.4 Ex command line ranges
	4.5 The window contents
	4.6 Abbreviations
	4.7 Digraphs
 5. Editing files
	5.1 Introduction
	5.2 Editing a file
	5.3 The argument list
	5.4 Writing and quitting
	5.5 Using the QuickFix mode
	5.6 Editing binary files
 6. Cursor motions
	6.1 Left-right motions
	6.2 Up-down motions
	6.3 Word motions
	6.4 Text object motions
	6.5 Pattern searches
	6.6 Various motions
 7. Scrolling
 8. Tags
 9. Inserting text
10. Deleting text
11. Changing text
	11.1 Delete and insert
	11.2 Simple changes
	11.3 Complex changes
12. Copying and moving text
13. Visual mode
14. Various commands
15. Repeating commands
	15.1 Single repeats
	15.2 Multiple repeats
	15.3 Complex repeats
16. Undo and redo
17. Key mapping
18. Recovery after a crash
	18.1 The swap file
	18.2 Recovery
19. Options
	19.1 Setting options
	19.2 Saving settings
	19.3 Options summary
20. Terminal information
	20.1 startup
	20.2 terminal options
	20.3 Window size
	20.4 slow and fast terminals
21. Differences from Vi and Ex
	21.1 Missing commands
	21.2 Missing options

vim:tw=76:ts=8:sw=8
